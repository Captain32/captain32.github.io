

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="张熙哲">
  <meta name="keywords" content="">
  
    <meta name="description" content="MySQL的存储引擎都是插件式的，在创建表的时候可以指定不同的存储引擎，这些存储引擎之间是独立的，都拥有自己的数据文件和日志，因此MySQL内部的事务都可以看成是一个微缩版的分布式事务，需要在多个存储引擎之间协调。虽然现在大多数Mysql使用者都只使用了一个存储引擎InnoDB，但是开了Binlog后，也可以把Binlog看作一个日志形式的存储引擎，所以Binlog本身也是参与方之一，因此需要在I">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL内部的两阶段提交">
<meta property="og:url" content="http://captain32.github.io/2023/10/15/MySQL%E5%86%85%E9%83%A8%E7%9A%84%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/index.html">
<meta property="og:site_name" content="Captain">
<meta property="og:description" content="MySQL的存储引擎都是插件式的，在创建表的时候可以指定不同的存储引擎，这些存储引擎之间是独立的，都拥有自己的数据文件和日志，因此MySQL内部的事务都可以看成是一个微缩版的分布式事务，需要在多个存储引擎之间协调。虽然现在大多数Mysql使用者都只使用了一个存储引擎InnoDB，但是开了Binlog后，也可以把Binlog看作一个日志形式的存储引擎，所以Binlog本身也是参与方之一，因此需要在I">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-10-15T15:11:12.000Z">
<meta property="article:modified_time" content="2023-10-15T15:19:09.074Z">
<meta property="article:author" content="张熙哲">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="两阶段提交">
<meta property="article:tag" content="组提交">
<meta property="article:tag" content="读源码">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>MySQL内部的两阶段提交 - Captain</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"captain32.github.io","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":["home"]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"0DHAyLeOfwqNRanYXNuL4Mhr-gzGzoHsz","app_key":"lq0Ly742okJc5yeBJcZaiHSF","server_url":"https://0dhayleo.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 65vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Captain&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/lake.jpeg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">MySQL内部的两阶段提交</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-10-15 23:11" pubdate>
          2023年10月15日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          24k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          204 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="MySQL"
        id="heading-62a004b95946bb97541afa471dcca73a" role="tab" data-toggle="collapse" href="#collapse-62a004b95946bb97541afa471dcca73a"
        aria-expanded="true"
      >
        MySQL
        <span class="list-group-count">(2)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-62a004b95946bb97541afa471dcca73a"
           role="tabpanel" aria-labelledby="heading-62a004b95946bb97541afa471dcca73a">
        
        
          
          
  <div class="category-post-list">
    
    
  </div>

          
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Server"
        id="heading-9aa1b03934893d7134a660af4204f2a9" role="tab" data-toggle="collapse" href="#collapse-9aa1b03934893d7134a660af4204f2a9"
        aria-expanded="true"
      >
        Server
        <span class="list-group-count">(2)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-9aa1b03934893d7134a660af4204f2a9"
           role="tabpanel" aria-labelledby="heading-9aa1b03934893d7134a660af4204f2a9">
        
        
          
          
  <div class="category-post-list">
    
    
  </div>

          
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Replication Layer"
        id="heading-34f55f77d09ea54d74fdb5040ba26611" role="tab" data-toggle="collapse" href="#collapse-34f55f77d09ea54d74fdb5040ba26611"
        aria-expanded="false"
      >
        Replication Layer
        <span class="list-group-count">(1)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-34f55f77d09ea54d74fdb5040ba26611"
           role="tabpanel" aria-labelledby="heading-34f55f77d09ea54d74fdb5040ba26611">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/" title="浅析MySQL GTID"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">浅析MySQL GTID</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Transaction Layer"
        id="heading-1cd6f50a25bb8aedc37496baf5f2d364" role="tab" data-toggle="collapse" href="#collapse-1cd6f50a25bb8aedc37496baf5f2d364"
        aria-expanded="true"
      >
        Transaction Layer
        <span class="list-group-count">(1)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-1cd6f50a25bb8aedc37496baf5f2d364"
           role="tabpanel" aria-labelledby="heading-1cd6f50a25bb8aedc37496baf5f2d364">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2023/10/15/MySQL%E5%86%85%E9%83%A8%E7%9A%84%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/" title="MySQL内部的两阶段提交"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">MySQL内部的两阶段提交</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
        
      </div>
    </div>
  
        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">MySQL内部的两阶段提交</h1>
            
            
              <div class="markdown-body">
                
                <p>MySQL的存储引擎都是插件式的，在创建表的时候可以指定不同的存储引擎，这些存储引擎之间是独立的，都拥有自己的数据文件和日志，因此MySQL内部的事务都可以看成是一个微缩版的分布式事务，需要在多个存储引擎之间协调。虽然现在大多数Mysql使用者都只使用了一个存储引擎InnoDB，但是开了Binlog后，也可以把Binlog看作一个日志形式的存储引擎，所以Binlog本身也是参与方之一，因此需要在InnoDB和Binlog之间进行2PC(两阶段提交)来提交一个事务。</p>
<h1 id="2PC协调者初始化"><a href="#2PC协调者初始化" class="headerlink" title="2PC协调者初始化"></a><strong>2PC协调者初始化</strong></h1><p>在2PC协议中有一个角色——协调者(Coordinator)，同样MySQL内部也需要一个这样的角色来协调参与方完成事务的提交，这个协调者就是代码中的全局变量tc_log，它是TC_LOG*类型的指针。TC_LOG类(Transaction Coordinator Log缩写)是一个接口类，主要是对外提供open、close、prepare、commit、rollback等方法，MYSQL_BIN_LOG类就继承了该类并且实现了这几个函数，在binlog开启的情况下，Mysql就会让mysql_bin_log来充当协调者的身份，这部分初始化代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* total_ha_2pc对存储引擎数目进行了计数，每个存储引擎初始化的时候会定义一个</span><br><span class="hljs-comment">   st_mysql_plugin结构体，其中type设置为MYSQL_STORAGE_ENGINE_PLUGIN，</span><br><span class="hljs-comment">   之后会调用plugin_type_initialize[type]函数也即ha_initialize_handlerton</span><br><span class="hljs-comment">   函数，该函数对存储引擎plugin进行初始化并更新total_ha_2pc。*/</span><br><span class="hljs-keyword">if</span> (total_ha_2pc &gt; <span class="hljs-number">1</span> || (<span class="hljs-number">1</span> == total_ha_2pc &amp;&amp; opt_bin_log)) &#123; <span class="hljs-comment">//参与方多于1就需要2PC</span><br>  <span class="hljs-keyword">if</span> (dg::<span class="hljs-built_in">server_is_standby_mode</span>()) &#123; <span class="hljs-comment">/* 在standby模式是没有开启binlog的，使用tc_log_dummy的实现方法基本为空，相当于没有2PC流程 */</span><br>    tc_log = &amp;tc_log_dummy;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt_bin_log) <span class="hljs-comment">//开启了binlog就让binlog做协调者</span><br>    tc_log = &amp;mysql_bin_log;<br>  <span class="hljs-keyword">else</span><br>    tc_log = &amp;tc_log_mmap;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="2PC流程"><a href="#2PC流程" class="headerlink" title="2PC流程"></a><strong>2PC流程</strong></h1><p>事务提交从ha_commit_trans函数开始，该函数里完成了2PC提交的全流程，下面是整个流程的调用栈，本小节会重点介绍入口函数和准备部分的内容，组提交放到下一小节展开介绍：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino">ha_commit_trans<br>├── MYSQL_BIN_LOG::prepare <span class="hljs-comment">//两阶段提交的准备阶段</span><br>│   └── ha_prepare_low<br>│       ├── binlog_prepare <span class="hljs-comment">//Binlog进行准备，没做什么事情，仅设置单语句事务的commit_parent</span><br>│       └── innobase_xa_prepare <span class="hljs-comment">//InnoDB进行准备，主要是获取了事务XID并且写入到事务对应Undo Log Header中</span><br>│           └── trx_prepare_for_mysql<br>│               └── trx_prepare<br>│                   └── trx_prepare<br>└── MYSQL_BIN_LOG::commit <span class="hljs-comment">//两阶段提交的提交阶段</span><br>    └── MYSQL_BIN_LOG::ordered_commit <span class="hljs-comment">//组提交，在本小节之后展开介绍</span><br></code></pre></td></tr></table></figure>
<h2 id="autocommit参数介绍"><a href="#autocommit参数介绍" class="headerlink" title="autocommit参数介绍"></a>autocommit参数介绍</h2><p>为了更好理解ha_commit_trans函数的入参，先了解一下相关背景知识。在Innodb中，所有的活动都是在事务中发生，哪怕只是一条单独的语句。Mysql有一个控制自动提交策略的变量autocommit：</p>
<ul>
<li>当autocommit开启(&#x3D;1)的时候：客户端发来的每一条语句都默认形成一个单独的事务，只不过这个事务只有一条语句，在语句执行成功后便被当作事务自动提交，无需客户端明确指认；一个包含多语句的事务则是由BEGIN和COMMIT显式包裹，这些语句作为一个整体原子地提交或者回滚。</li>
<li>当autocommit关闭(&#x3D;0)的时候：客户端发来的每一条语句在没有COMMIT或ROLLBACK显式指认的情况下，都不会被当作事务自动提交，当COMMIT被客户端发出后，前面的所有语句被当作一个事务进行提交，并且同时开启下一个事务。</li>
</ul>
<p>关于autocommit更为详细的介绍可见官方文档<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-autocommit-commit-rollback.html">15.7.2.2 autocommit, Commit, and Rollback</a>。除了autocommit开启时会自动提交单语句事务外，还有一种情况会在客户端不显式指认COMMIT时提交事务，那就是隐式提交，很多DDL语句的执行都会导致当前事务被截断然后提交，就像是在DDL语句前加了一个COMMIT一样，这些DDL语句详见官方文档<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/implicit-commit.html">13.3.3 Statements That Cause an Implicit Commit</a>。</p>
<p>由上面的介绍可知，事务的提交可以简单分为三种情况：</p>
<ol>
<li>正常事务提交(Normal transaction，从trans_commit函数发起调用)，这是由客户端指定的事务，在autocommit开启的情况下是由BEGIN和COMMIT包裹，autocommit关闭时则是由前后两个COMMIT&#x2F;ROLLBACK包裹。</li>
<li>单语句事务提交(Statement transaction，从trans_commit_stmt函数发起调用)，这是在autocommit开启的情况下，每一个不在正常事务中的语句都会被单独组织成一个单语句事务进行提交，这种事务用户是无法通过ROLLBACK回滚的。</li>
<li>隐式事务提交(Implicit commit，从trans_commit_implicit函数发起调用)，这是一些DDL语句导致的进行中的事务被隐式提交。</li>
</ol>
<h2 id="入口函数-ha-commit-trans"><a href="#入口函数-ha-commit-trans" class="headerlink" title="入口函数 ha_commit_trans"></a>入口函数 ha_commit_trans</h2><p>有了这些背景知识，再来看ha_commit_trans函数的三个入参，其中all就是用来区分是否单语句事务的：</p>
<table>
<thead>
<tr>
<th>THD *thd</th>
<th>当前线程</th>
</tr>
</thead>
<tbody><tr>
<td>bool all</td>
<td>True：正常事务或者隐式提交</td>
</tr>
<tr>
<td>False：单语句事务</td>
<td></td>
</tr>
<tr>
<td>bool ignore_global_read_lock</td>
<td>是否可以无视全局读锁，该参数可以被用于修改内部表</td>
</tr>
</tbody></table>
<p>ha_commit_trans函数主要干了以下两件事情：</p>
<ol>
<li>根据参数all确定事务是单语句事务还是另外两种事务，据此可以确定参与的引擎(执行过程中发生写操作时会把自己登记进去)有哪些</li>
<li>参与方大于1那么就需要2PC来完成提交，接下来就分别调用tc_log-&gt;prepare和tc_log-&gt;commit</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ha_commit_trans</span><span class="hljs-params">(THD *thd, <span class="hljs-type">bool</span> all, <span class="hljs-type">bool</span> ignore_global_read_lock)</span> </span>&#123;<br>  ...<br>  <span class="hljs-comment">/* 事务上下文trn_ctx中的m_scope_info数组维护了两个THD_TRANS，两个THD_TRANS</span><br><span class="hljs-comment">     在不同的情况下被起用，正常事务和隐式提交用的是m_scope_info[1]，单语句事务用</span><br><span class="hljs-comment">     的是m_scope_info[0]，而Transaction_ctx::SESSION与Transaction_ctx::STMT</span><br><span class="hljs-comment">     就分别对应的1和0。于是通过ha_trx_info函数就可以获得相应THD_TRANS的成员变量</span><br><span class="hljs-comment">     m_ha_list，这个list里面存的是本事务影响(修改)到的所有存储引擎，每个存储引擎</span><br><span class="hljs-comment">     都在自己被修改时使用trans_register_ha函数将自己登记进去，这个函数是幂等的。*/</span><br>  Transaction_ctx *trn_ctx = thd-&gt;<span class="hljs-built_in">get_transaction</span>();<br>  Transaction_ctx::enum_trx_scope trx_scope = all ? Transaction_ctx::SESSION : Transaction_ctx::STMT;<br>  <span class="hljs-keyword">auto</span> ha_info = trn_ctx-&gt;<span class="hljs-built_in">ha_trx_info</span>(trx_scope);<br>  ...<br>  <span class="hljs-keyword">if</span> (ha_info &amp;&amp; !error) &#123;<br>    ...<br>    <span class="hljs-comment">/* 判断本事务是不是读写事务，is_real_trans在事务是正常事务、隐式提交或不处于</span><br><span class="hljs-comment">       正常事务内的单语句事务时为True，rw_ha_count则是对本事务修改的引擎数量进行</span><br><span class="hljs-comment">       计数，如果只是读了一个引擎那么将被跳过计数，大于0意味着至少对一个引擎进行了</span><br><span class="hljs-comment">       修改 */</span><br>    rw_trans = is_real_trans &amp;&amp; (rw_ha_count &gt; <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (rw_trans &amp;&amp; !ignore_global_read_lock) &#123;<br>      ...<br>      <span class="hljs-comment">/* 获取MDL锁，这保证事务提交会被FLUSH TABLES WITH READ LOCK语句阻塞 */</span><br>      <span class="hljs-built_in">MDL_REQUEST_INIT</span>(&amp;mdl_request, MDL_key::COMMIT, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>,<br>                       MDL_INTENTION_EXCLUSIVE, MDL_EXPLICIT);<br>      <span class="hljs-keyword">if</span> (thd-&gt;mdl_context.<span class="hljs-built_in">acquire_lock</span>(&amp;mdl_request, thd-&gt;variables.lock_wait_timeout))<br>      ...<br>    &#125;<br>    ...<br>    <span class="hljs-comment">/* no_2pc函数检查所有参与的存储引擎是否支持2PC协议，rw_ha_count则是前面计算得到的 */</span><br>    <span class="hljs-keyword">if</span> (!trn_ctx-&gt;<span class="hljs-built_in">no_2pc</span>(trx_scope) &amp;&amp; (trn_ctx-&gt;<span class="hljs-built_in">rw_ha_count</span>(trx_scope) &gt; <span class="hljs-number">1</span>))<br>      <span class="hljs-comment">/* 通过tc_log(开启binlog的话就是binlog)的prepare函数让所有参与的引擎prepare */</span><br>      error = tc_log-&gt;<span class="hljs-built_in">prepare</span>(thd, all);<br>  &#125;<br>  ... <span class="hljs-comment">/* 外部XA事务相关的先不关注 */</span><br>  <span class="hljs-comment">/* 通过tc_log让所有参与的存储引擎提交 */</span><br>  <span class="hljs-keyword">if</span> (error || (error = tc_log-&gt;<span class="hljs-built_in">commit</span>(thd, all)))<br>  ... <span class="hljs-comment">/* 清理工作，释放MDL锁等等 */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在InnoDB搭配Binlog的情况下，这个tc_log指针指向的就是mysql_bin_log，走的是MYSQL_BIN_LOG实现的两个方法，所以接下来看看这两个函数干了什么。</p>
<h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><p>其实MYSQL_BIN_LOG::prepare函数本身实现很简单，就干了两件事：</p>
<ol>
<li>设置durability_property延缓引擎层Redo Log刷盘</li>
<li>透传调用ha_prepare_low函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MYSQL_BIN_LOG::prepare</span><span class="hljs-params">(THD *thd, <span class="hljs-type">bool</span> all)</span> </span>&#123;<br>  ...<br>  <span class="hljs-comment">/* 为了减少IO次数，设置durability_property使得存储引擎InnoDB暂缓将Redo Log刷盘，</span><br><span class="hljs-comment">     延迟到最后组提交阶段成组刷盘 */</span><br>  thd-&gt;durability_property = HA_IGNORE_DURABILITY;<br>  <span class="hljs-comment">/* 透传参数到ha_prepare_low */</span><br>  <span class="hljs-type">int</span> error = <span class="hljs-built_in">ha_prepare_low</span>(thd, all);<br>  ... <span class="hljs-comment">/* 外部XA事务相关的先不关注 */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>以Innodb为例，durability_property设置为HA_IGNORE_DURABILITY会在准备阶段跳过对Redo Log的刷盘：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">trx_flush_logs</span><span class="hljs-params">(<span class="hljs-type">trx_t</span> *trx, <span class="hljs-type">lsn_t</span> lsn)</span> </span>&#123;<br>  ...<br>  <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">thd_requested_durability</span>(trx-&gt;mysql_thd)) &#123;<br>    <span class="hljs-keyword">case</span> HA_IGNORE_DURABILITY:<br>      <span class="hljs-keyword">break</span>; <span class="hljs-comment">//直接跳过刷盘</span><br>    <span class="hljs-keyword">case</span> HA_REGULAR_DURABILITY:<br>      trx-&gt;ddl_must_flush = <span class="hljs-literal">false</span>;<br>      <span class="hljs-built_in">trx_flush_log_if_needed</span>(lsn, trx);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>透传调用的ha_prepare_low函数也很简单，将所有事务参与方的prepare函数都掉用了一遍，并做了一些计数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ha_prepare_low</span><span class="hljs-params">(THD *thd, <span class="hljs-type">bool</span> all)</span> </span>&#123;<br>  ...<br>  <span class="hljs-comment">/* 获得本事务影响(修改)到的存储引擎的链表 */</span><br>  <span class="hljs-keyword">auto</span> ha_list = thd-&gt;<span class="hljs-built_in">get_transaction</span>()-&gt;<span class="hljs-built_in">ha_trx_info</span>(trx_scope);<br>  <span class="hljs-keyword">if</span> (ha_list) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> &amp;ha_info : ha_list) &#123; <span class="hljs-comment">//遍历所有引擎信息</span><br>      ... <span class="hljs-comment">/* 一些读写以及外部XA事务检查 */</span><br>      <span class="hljs-comment">/* 获得引擎对应的handlerton，binlog对应的是binlog_hton，</span><br><span class="hljs-comment">         Innodb对应的是innobase_hton，分别在各自初始化时准备好 */</span><br>      <span class="hljs-keyword">auto</span> ht = ha_info.<span class="hljs-built_in">ht</span>();<br>      <span class="hljs-comment">/* 调用引擎handlerton的prepare函数 */</span><br>      <span class="hljs-type">int</span> err = ht-&gt;<span class="hljs-built_in">prepare</span>(ht, thd, all);<br>      ...<br>      <span class="hljs-comment">/* 事务参与方准备完成计数+1 */</span><br>      thd-&gt;status_var.ha_prepare_count++;<br>      ...<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>到这里，先确定一下Binlog和InnoDB各自的prepare函数是什么，看一下binlog_hton和innobase_hton各自的初始化可以发现，两者的prepare函数分别是binlog_prepare函数和innobase_xa_prepare函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">binlog_init</span><span class="hljs-params">(<span class="hljs-type">void</span> *p)</span> </span>&#123;<br>  binlog_hton = (handlerton *)p;<br>  ...<br>  binlog_hton-&gt;commit = binlog_commit;<br>  binlog_hton-&gt;rollback = binlog_rollback;<br>  binlog_hton-&gt;prepare = binlog_prepare;<br>  ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">innodb_init</span><span class="hljs-params">(<span class="hljs-type">void</span> *p)</span> </span>&#123;<br>  handlerton *innobase_hton = (handlerton *)p;<br>  ...<br>  innobase_hton-&gt;commit = innobase_commit;<br>  innobase_hton-&gt;rollback = innobase_rollback;<br>  innobase_hton-&gt;prepare = innobase_xa_prepare;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Binlog准备"><a href="#Binlog准备" class="headerlink" title="Binlog准备"></a>Binlog准备</h4><p>对于binlog而言，事务过程中已经把操作写入binlog cache，只需要最终挪到binlog文件中，所以可以认为本身就处于prepare状态，于是binlog_prepare这个函数实现就非常简单，对于单语句事务设置一下commit_parent(用于确定备库回放顺序)即可，详情如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">binlog_prepare</span><span class="hljs-params">(handlerton *, THD *thd, <span class="hljs-type">bool</span> all)</span> </span>&#123;<br>  <span class="hljs-comment">//只有单语句事务需要设置一下commit_parent</span><br>  <span class="hljs-keyword">if</span> (!all) &#123;<br>    thd-&gt;<span class="hljs-built_in">get_transaction</span>()-&gt;<span class="hljs-built_in">store_commit_parent</span>(mysql_bin_log.m_dependency_tracker.<span class="hljs-built_in">get_max_committed_timestamp</span>());<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="InnoDB准备"><a href="#InnoDB准备" class="headerlink" title="InnoDB准备"></a>InnoDB准备</h4><p>Innodb的prepare阶段就要复杂一些，下面是innobase_xa_prepare函数的主干：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">innobase_xa_prepare</span><span class="hljs-params">(handlerton *hton, THD *thd, <span class="hljs-type">bool</span> prepare_trx)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* 根据线程thd获得Innodb对应的事务对象trx */</span><br>  <span class="hljs-type">trx_t</span> *trx = <span class="hljs-built_in">check_trx_exists</span>(thd);<br>  <span class="hljs-comment">/* 从线程获取事务的xid写到trx-&gt;xid中 */</span><br>  <span class="hljs-built_in">thd_get_xid</span>(thd, (MYSQL_XID *)trx-&gt;xid);<br>  ...<br>  <span class="hljs-comment">/* prepare_trx就是透传的all，代表正常事务提交和隐式提交，对于autocommit模式下</span><br><span class="hljs-comment">     的单语句，只要不是BEGIN语句，就当作单语句事务提交 */</span><br>  <span class="hljs-keyword">if</span> (prepare_trx || (!<span class="hljs-built_in">thd_test_options</span>(thd, OPTION_NOT_AUTOCOMMIT | OPTION_BEGIN))) &#123;<br>    <span class="hljs-comment">/* 内部简单检查后透传调用trx_prepare */</span><br>    <span class="hljs-type">dberr_t</span> err = <span class="hljs-built_in">trx_prepare_for_mysql</span>(trx);<br>    ...<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看出该函数根据thd获得Innodb内部的事务对象，并且给它设置了XID，经过检查后调用trx_prepare_for_mysql函数，trx_prepare_for_mysql函数也有简单检查随后便直接透传调用了trx_prepare函数，在完成调用后设置事务状态为TRX_STATE_PREPARED即可，详情如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">trx_prepare</span><span class="hljs-params">(<span class="hljs-type">trx_t</span> *trx)</span> </span>&#123;<br>  <span class="hljs-type">lsn_t</span> lsn = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">/* trx-&gt;rsegs是分配给本事务Undo Segment的Rollback Segment们的关联信息，有两种分类：</span><br><span class="hljs-comment">  	 也就是两个if语句中的m_redo和m_noredo，m_redo是驻留在系统/Undo Tablespace</span><br><span class="hljs-comment">     中的Rollback Segment，需要在redo log中进行持久化；m_noredo则是驻留在临时</span><br><span class="hljs-comment">     Tablespace中的Rollback Segment，不需要持久化，所以第一个有分配Redo Log中</span><br><span class="hljs-comment">     的LSN，第二个没有。 */</span><br>  <span class="hljs-keyword">if</span> (trx-&gt;rsegs.m_redo.rseg != <span class="hljs-literal">nullptr</span> &amp;&amp; <span class="hljs-built_in">trx_is_redo_rseg_updated</span>(trx)) &#123;<br>    <span class="hljs-comment">/* 将对应Rollback Segment中本事务的Insert Undo Log和Update Undo Log设置为准备状态 */</span><br>    lsn = <span class="hljs-built_in">trx_prepare_low</span>(trx, &amp;trx-&gt;rsegs.m_redo, <span class="hljs-literal">false</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (trx-&gt;rsegs.m_noredo.rseg != <span class="hljs-literal">nullptr</span> &amp;&amp; <span class="hljs-built_in">trx_is_temp_rseg_updated</span>(trx)) &#123;<br>    <span class="hljs-built_in">trx_prepare_low</span>(trx, &amp;trx-&gt;rsegs.m_noredo, <span class="hljs-literal">true</span>);<br>  &#125;<br><br>  <span class="hljs-comment">/* 设置事务状态为prepared */</span><br>  <span class="hljs-built_in">trx_sys_mutex_enter</span>();<br>  trx-&gt;state.<span class="hljs-built_in">store</span>(TRX_STATE_PREPARED, std::memory_order_relaxed);<br>  trx_sys-&gt;n_prepared_trx++;<br>  <span class="hljs-built_in">trx_sys_mutex_exit</span>();<br><br>  ... <span class="hljs-comment">/* 读已提交及其之下隔离级别的需要释放间隙锁 */</span><br>    <br>  <span class="hljs-comment">/* Redo Log刷盘，但是之前binlog作为协调者准备时设置了HA_IGNORE_DURABILITY，</span><br><span class="hljs-comment">     组提交为了避免频繁刷盘，在5.7版本中修改了组提交的flush阶段，在prepare阶段不</span><br><span class="hljs-comment">     再让线程各自执行flush redolog操作，而是推迟到组提交的flush阶段。 */</span><br>  <span class="hljs-keyword">if</span> (lsn &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">trx_flush_logs</span>(trx, lsn);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>再进一步看一下trx_prepare_low函数的主体逻辑，这个函数主要将事务相关的Undo Log调整为prepare状态，关于Undo Log相关数据结构见<a target="_blank" rel="noopener" href="https://www.yuque.com/captain32/space/ek259gm6zgrr5wrr?view=doc_embed">Undo Log基本数据结构</a>，该函数详情如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">lsn_t</span> <span class="hljs-title">trx_prepare_low</span><span class="hljs-params">(<span class="hljs-type">trx_t</span> *trx, <span class="hljs-type">trx_undo_ptr_t</span> *undo_ptr, <span class="hljs-type">bool</span> noredo_logging)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/* 事务有Insert类型Undo Log或者Update类型Undo Log，需要把相应的Undo Log设置为准备状态 */</span><br>  <span class="hljs-keyword">if</span> (undo_ptr-&gt;insert_undo != <span class="hljs-literal">nullptr</span> || undo_ptr-&gt;update_undo != <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-type">mtr_t</span> mtr;<br>    <span class="hljs-comment">/* 事务Undo Log所在的Rollback Segment */</span><br>    <span class="hljs-type">trx_rseg_t</span> *rseg = undo_ptr-&gt;rseg;<br><br>    <span class="hljs-comment">/* 开启一个Mini Transaction(引擎层内部小事务)，后面涉及硬盘内容的更新 */</span><br>    <span class="hljs-built_in">mtr_start_sync</span>(&amp;mtr);<br><br>    <span class="hljs-keyword">if</span> (noredo_logging) &#123;<br>      <span class="hljs-comment">/* 临时Tablespace下不需要将Undo Log本身录入Redo Log，这里不让MTR写到Redo Log */</span><br>      <span class="hljs-built_in">mtr_set_log_mode</span>(&amp;mtr, MTR_LOG_NO_REDO);<br>    &#125;<br><br>    rseg-&gt;<span class="hljs-built_in">latch</span>();<br>    <span class="hljs-keyword">if</span> (undo_ptr-&gt;insert_undo != <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">/* 处理Insert类型Undo Log */</span><br>      <span class="hljs-comment">//设置Undo Segment在文件、内存层面的状态，向Undo Log Header中写入xid</span><br>      <span class="hljs-built_in">trx_undo_set_state_at_prepare</span>(trx, undo_ptr-&gt;insert_undo, <span class="hljs-literal">false</span>, &amp;mtr);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (undo_ptr-&gt;update_undo != <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">/* 处理Update类型Undo Log */</span><br>      <span class="hljs-keyword">if</span> (!noredo_logging) &#123;<br>        <span class="hljs-comment">/* 设置Undo Log对象的m_gtid_storage字段为PREPARE_AND_COMMIT */</span><br>        <span class="hljs-built_in">trx_undo_gtid_set</span>(trx, undo_ptr-&gt;update_undo, <span class="hljs-literal">true</span>);<br>      &#125;<br>      <span class="hljs-comment">/* 与上面Insert类型类似，设置xid到Undo Log Header中 */</span><br>      <span class="hljs-built_in">trx_undo_set_state_at_prepare</span>(trx, undo_ptr-&gt;update_undo, <span class="hljs-literal">false</span>, &amp;mtr);<br>    &#125;<br>    rseg-&gt;<span class="hljs-built_in">unlatch</span>();<br>    <br>    <span class="hljs-comment">/* 其实是mtr.commit()，内部调用Command::execute()函数，正常情况下写Redo Log，</span><br><span class="hljs-comment">       同时更新m_commit_lsn */</span><br>    <span class="hljs-built_in">mtr_commit</span>(&amp;mtr);<br><br>    <span class="hljs-keyword">if</span> (!noredo_logging) &#123; <span class="hljs-comment">/* 如果Undo Log本身变更需要录入Redo Log，获取lsn */</span><br>      <span class="hljs-comment">/* 获取m_commit_lsn，也就是刚才提交的小事务在Redo Log中的位置 */</span><br>      <span class="hljs-type">const</span> <span class="hljs-type">lsn_t</span> lsn = mtr.<span class="hljs-built_in">commit_lsn</span>();<br>      <span class="hljs-keyword">return</span> lsn;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h3><p>MYSQL_BIN_LOG::commit函数大部分内容是在为最终组提交做准备工作，首先对于非空的stmt_cache(单语句事务使用)和trx_cache(显式事务使用)，会视情况添加XID Event，并且调用finalize方法标记写入Binlog结束，来为之后组提交的flush做准备。当binlog cache完成了写入，就意味着所有需要持久化的内容都已经在cache中，之后就可以调用ordered_commit函数(下一小节详细介绍)开始组提交，详情如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TC_LOG::enum_result <span class="hljs-title">MYSQL_BIN_LOG::commit</span><span class="hljs-params">(THD *thd, <span class="hljs-type">bool</span> all)</span> </span>&#123;<br>  Transaction_ctx *trn_ctx = thd-&gt;<span class="hljs-built_in">get_transaction</span>();<br>  my_xid xid = trn_ctx-&gt;<span class="hljs-built_in">xid_state</span>()-&gt;<span class="hljs-built_in">get_xid</span>()-&gt;<span class="hljs-built_in">get_my_xid</span>();<br>  <span class="hljs-type">bool</span> stmt_stuff_logged = <span class="hljs-literal">false</span>;<br>  <span class="hljs-type">bool</span> trx_stuff_logged = <span class="hljs-literal">false</span>;<br>  ...<br>  <span class="hljs-comment">/* 获得本线程的binlog cache manager */</span><br>  binlog_cache_mngr *cache_mngr = <span class="hljs-built_in">thd_get_cache_mngr</span>(thd);<br>  ...<br>  <span class="hljs-comment">/* 类似之前，用all区分非单语句事务和单语句事务 */</span><br>  Transaction_ctx::enum_trx_scope trx_scope = all ? Transaction_ctx::SESSION : Transaction_ctx::STMT;<br>  <br>  <span class="hljs-comment">/* 单语句事务的binlog cache非空，则需要提交 */</span><br>  <span class="hljs-keyword">if</span> (!cache_mngr-&gt;stmt_cache.<span class="hljs-built_in">is_binlog_empty</span>()) &#123;<br>    <span class="hljs-comment">/* 设置commit parent为最近提交的事务 */</span><br>    trn_ctx-&gt;<span class="hljs-built_in">store_commit_parent</span>(m_dependency_tracker.<span class="hljs-built_in">get_max_committed_timestamp</span>());<br>    <span class="hljs-comment">/* finalize函数会标记flags.finalized为true，意味着事务完成binlog cache</span><br><span class="hljs-comment">       的写入，只有经过这一步之后才可以将内容从cache刷到文件 */</span><br>    <span class="hljs-keyword">if</span> (cache_mngr-&gt;stmt_cache.<span class="hljs-built_in">finalize</span>(thd)) <span class="hljs-keyword">return</span> RESULT_ABORTED;<br>    <span class="hljs-comment">/* 设置stmt_stuff_logged为true，用于后续判断，可以进入组提交流程 */</span><br>    stmt_stuff_logged = <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/* ending_trans就是简单判断all为true(正常事务、隐式提交)，或者是单语句事务，</span><br><span class="hljs-comment">     也即需要提交的事务。trx_stuff_logged会在本if末尾处设置为true供后续判断 */</span><br>  <span class="hljs-keyword">if</span> (!cache_mngr-&gt;trx_cache.<span class="hljs-built_in">is_binlog_empty</span>() &amp;&amp; <span class="hljs-built_in">ending_trans</span>(thd, all) &amp;&amp; !trx_stuff_logged) &#123;<br>    <span class="hljs-comment">/* 再一次判断，就是正常事务、隐式提交、单语句事务三种 */</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> real_trans = (all || !trn_ctx-&gt;<span class="hljs-built_in">is_active</span>(Transaction_ctx::SESSION));<br>    <br>    <span class="hljs-keyword">if</span>() ... <span class="hljs-comment">//外部XA事务相关    </span><br>    <span class="hljs-comment">/* 原子DDL直接finalize binlog cache */</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((is_atomic_ddl = cache_mngr-&gt;trx_cache.<span class="hljs-built_in">has_xid</span>())) &#123;<br>      <span class="hljs-keyword">if</span> (cache_mngr-&gt;trx_cache.<span class="hljs-built_in">finalize</span>(thd, <span class="hljs-literal">nullptr</span>)) <span class="hljs-keyword">return</span> RESULT_ABORTED;<br>    &#125;<br>    <span class="hljs-comment">/* 为事务将xid event记入binlog cache，并且进行finalize */</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (real_trans &amp;&amp; xid &amp;&amp; trn_ctx-&gt;<span class="hljs-built_in">rw_ha_count</span>(trx_scope) &gt; <span class="hljs-number">1</span> &amp;&amp; !trn_ctx-&gt;<span class="hljs-built_in">no_2pc</span>(trx_scope)) &#123;<br>      Xid_log_event <span class="hljs-built_in">end_evt</span>(thd, xid);<br>      <span class="hljs-keyword">if</span> (cache_mngr-&gt;trx_cache.<span class="hljs-built_in">finalize</span>(thd, &amp;end_evt)) <span class="hljs-keyword">return</span> RESULT_ABORTED;<br>    &#125;<br>    <span class="hljs-comment">/* 其他情况补一个COMMIT在binlog cache的最后并finalize */</span><br>    <span class="hljs-keyword">else</span> &#123;<br>      Query_log_event <span class="hljs-built_in">end_evt</span>(thd, <span class="hljs-built_in">STRING_WITH_LEN</span>(<span class="hljs-string">&quot;COMMIT&quot;</span>), <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>      <span class="hljs-keyword">if</span> (cache_mngr-&gt;trx_cache.<span class="hljs-built_in">finalize</span>(thd, &amp;end_evt)) <span class="hljs-keyword">return</span> RESULT_ABORTED;<br>    &#125;<br>    <span class="hljs-comment">/* 设置为true用于之后进入组提交 */</span><br>    trx_stuff_logged = <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/* 根据之前设置的stmt_stuff_logged和trx_stuff_logged，开启组提交 */</span><br>  <span class="hljs-keyword">if</span> (stmt_stuff_logged || trx_stuff_logged) &#123;<br>    ...<br>    <span class="hljs-comment">/* 组提交 */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ordered_commit</span>(thd, all, skip_commit)) <span class="hljs-keyword">return</span> RESULT_INCONSISTENT;<br>    ... <span class="hljs-comment">/* 外部XA事务相关 */</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!skip_commit) &#123;<br>    <span class="hljs-keyword">if</span> (trx_coordinator::<span class="hljs-built_in">commit_in_engines</span>(thd, all))<br>      <span class="hljs-keyword">return</span> RESULT_INCONSISTENT;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> RESULT_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="组提交"><a href="#组提交" class="headerlink" title="组提交"></a>组提交</h1><p>当有多个事务并发执行时，redo log是可以穿插记录不同事务所做修改的，但是binlog不允许不同事务穿插记录，所以就需要每个事务先将自己所有的event记录到独占的binlog cache中，直到提交的时候，将binlog cache中所有内容作为一个整体刷到binlog文件中，这样就避免了不同事务日志的穿插。</p>
<p>事务是有多个的，但是binlog文件只有一个，因此这些事务之间也存在竞争，最简单的想法就是用一把锁保护binlog文件，持有锁的事务才可以将自己的binlog cache刷到binlog文件中，这也是5.6 版本之前的做法，在2PC前需要获得这把锁，提交完成后再释放锁，因此同一时刻只能有一个事务在2PC流程中，这显然大大降低了并发度。</p>
<p>5.6版本引入了组提交，组提交将2PC的提交阶段分为了三步：</p>
<ol>
<li>flush stage：多个线程按进入的顺序将 binlog 从 cache 写入文件（不刷盘）</li>
<li>sync stage：对 binlog 文件做 fsync 操作（多个线程的 binlog 合并一次刷盘）</li>
<li>commit stage：各个线程按顺序做InnoDB commit操作(ha_commit_low)，这里没有刷盘</li>
</ol>
<p>这三步每一步都有锁进行保护，各自维护自己的队列，其中第2步是提升性能的关键，合并刷盘可以让各个事务日志刷盘的均摊IO消耗大大降低。并且因为锁的粒度减小，三步可以并发执行，形成了流水线一样的流程。</p>
<p>组提交可以大幅提升多事务提交的性能，但是2PC的性能瓶颈也从commit阶段转移到了prepare阶段，原因是prepare阶段每个事务都对Redo Log进行了刷盘，因此5.7版本将这一步后推(也就有了之前Prepare阶段设置HA_IGNORE_DURABILITY)到了commit阶段的flush stage，于是新的flush stage不光要完成binlog cache写入文件，还要完成Redo Log的刷盘，就相当于为Redo Log做了一次组写入。于是2PC的提交阶段变为：</p>
<ol>
<li>flush stage：完成Redo Log刷盘，多个线程按进入的顺序将 binlog 从 cache 写入文件（不刷盘）</li>
<li>sync stage：对 binlog 文件做 fsync 操作（多个线程的 binlog 合并一次刷盘）</li>
<li>commit stage：各个线程按顺序做InnoDB commit操作(ha_commit_low)，在Redo Log中给事务添加Commit标记，这个不要求刷盘，因为不影响故障恢复</li>
</ol>
<p>接下来看一下组提交ordered_commit的详细实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MYSQL_BIN_LOG::ordered_commit</span><span class="hljs-params">(THD *thd, <span class="hljs-type">bool</span> all, <span class="hljs-type">bool</span> skip_commit)</span> </span>&#123;<br>  ... <span class="hljs-comment">/* 备库回放需要等待的Stage 0，略过 */</span><br><br>  <span class="hljs-comment">/* Stage 1: 进入flush stage */</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">change_stage</span>(thd, Commit_stage_manager::BINLOG_FLUSH_STAGE, thd, <span class="hljs-literal">nullptr</span>, &amp;LOCK_log)) &#123;<br>    <span class="hljs-comment">/* 非leader线程醒来后直接finish即可，leader已经帮自己做了所有事 */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">finish_commit</span>(thd);<br>  &#125;<br>  ...<br>  <span class="hljs-comment">/* 处理flush stage queue中所有事务，包括刷盘Redo Log，分配事务GTID，把所有事务的</span><br><span class="hljs-comment">  	 binlog cache写到binlog的内存Buffer中 */</span><br>  flush_error = <span class="hljs-built_in">process_flush_stage_queue</span>(&amp;total_bytes, &amp;do_rotate, &amp;wait_queue);<br>  <span class="hljs-keyword">if</span> (flush_error == <span class="hljs-number">0</span> &amp;&amp; total_bytes &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">/* 最终调用的是m_binlog_file-&gt;m_pipeline_head-&gt;flush()，这里才真正把</span><br><span class="hljs-comment">      binlog内存Buffer中内容刷到操作系统Page Cache中 */</span><br>    flush_error = <span class="hljs-built_in">flush_cache_to_file</span>(&amp;flush_end_pos);<br>  &#125;<br>  ... <span class="hljs-comment">/* 设置binlog end pos、错误处理等 */</span><br>  <br><br>  <span class="hljs-comment">/* Stage 2: 进入sync stage */</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">change_stage</span>(thd, Commit_stage_manager::SYNC_STAGE, wait_queue, &amp;LOCK_log, &amp;LOCK_sync)) &#123;<br>    <span class="hljs-comment">/* 非leader线程醒来后直接finish即可，leader已经帮自己做了所有事 */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">finish_commit</span>(thd);<br>  &#125;<br>  <span class="hljs-comment">/* get_sync_period函数其实就是sync_binlog参数，sync_counter是有多少组进入到</span><br><span class="hljs-comment">     该stage的计数，sync_counter+1的语义就是算上目前这组是否达到了sync_binlog的</span><br><span class="hljs-comment">     要求，在之后sync_binlog_file函数里面会再判断一次，用于决定是否sync。例如</span><br><span class="hljs-comment">     sync_binlog=1代表每一组都达到要求得sync，sync_binlog=1000代表每1000组sync</span><br><span class="hljs-comment">     一次，特例是sync_binlog=0，会直接跳过sync。</span><br><span class="hljs-comment">     在这里if判断是为了binlog_group_commit_sync_no_delay_count和</span><br><span class="hljs-comment">     opt_binlog_group_commit_sync_delay两个参数，分别决定了启动sync所需的事务</span><br><span class="hljs-comment">     数量和最大等待时间，故意等待是为了增加备库回放的并行度。特例sync_binlog=0也会</span><br><span class="hljs-comment">     在这里被留下来等待。效果就是flush阶段的多个组合并成了一个组，一起刷盘。 */</span><br>  <span class="hljs-keyword">if</span> (!flush_error &amp;&amp; (sync_counter + <span class="hljs-number">1</span> &gt;= <span class="hljs-built_in">get_sync_period</span>()))<br>    Commit_stage_manager::<span class="hljs-built_in">get_instance</span>().<span class="hljs-built_in">wait_count_or_timeout</span>(<br>        opt_binlog_group_commit_sync_no_delay_count,<br>        opt_binlog_group_commit_sync_delay, Commit_stage_manager::SYNC_STAGE);<br><br>  <span class="hljs-comment">/* 获得sync stage队列，并且清空队列，使得新的一组可以开始组装 */</span><br>  final_queue = Commit_stage_manager::<span class="hljs-built_in">get_instance</span>().<span class="hljs-built_in">fetch_queue_acquire_lock</span>(<br>      Commit_stage_manager::SYNC_STAGE);<br>  <span class="hljs-comment">/* binlog进行sync，其中sync_binlog_file会再次判断sync_counter是否达到</span><br><span class="hljs-comment">     sync_binlog要求，满足才进行sync，否则跳过 */</span><br>  <span class="hljs-keyword">if</span> (flush_error == <span class="hljs-number">0</span> &amp;&amp; total_bytes &gt; <span class="hljs-number">0</span>) &#123;<br>    std::pair&lt;<span class="hljs-type">bool</span>, <span class="hljs-type">bool</span>&gt; result = <span class="hljs-built_in">sync_binlog_file</span>(<span class="hljs-literal">false</span>);<br>    sync_error = result.first;<br>  &#125;<br>  <span class="hljs-comment">/* 根据需要更新binlog文件在内存中的end pos */</span><br>  <span class="hljs-keyword">if</span> (update_binlog_end_pos_after_sync &amp;&amp; flush_error == <span class="hljs-number">0</span> &amp;&amp; sync_error == <span class="hljs-number">0</span>) &#123;<br>    ... <span class="hljs-comment">/* 获取final_queue存的这组事务中的最大end_pos并更新binlog的end pos */</span><br>  &#125;<br>  <span class="hljs-comment">/* 用于等会儿释放锁 */</span><br>  leave_mutex_before_commit_stage = &amp;LOCK_sync;<br><br>  <span class="hljs-comment">/* 判断是否需要commit order，不需要的话就直接让各个事务自己commit就好了，不维持顺序 */</span><br>  <span class="hljs-keyword">if</span> ((opt_binlog_order_commits || Clone_handler::<span class="hljs-built_in">need_commit_order</span>()) &amp;&amp;<br>      (sync_error == <span class="hljs-number">0</span> || binlog_error_action != ABORT_SERVER)) &#123;<br>    <span class="hljs-comment">/* Stage 3: 进入commit stage */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">change_stage</span>(thd, Commit_stage_manager::COMMIT_STAGE, final_queue, leave_mutex_before_commit_stage, &amp;LOCK_commit)) &#123;<br>      <span class="hljs-comment">/* 非leader线程醒来后直接finish即可，leader已经帮自己做了所有事 */</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">finish_commit</span>(thd);<br>    &#125;<br>    <span class="hljs-comment">/* 获得commit stage队列，并且清空队列，使得新的一组可以开始组装 */</span><br>    THD *commit_queue = Commit_stage_manager::<span class="hljs-built_in">get_instance</span>().<span class="hljs-built_in">fetch_queue_acquire_lock</span>(Commit_stage_manager::COMMIT_STAGE);<br>    ...<br>    <span class="hljs-comment">/* 在Innodb引擎中逐个提交事务，维持了顺序 */</span><br>    <span class="hljs-built_in">process_commit_stage_queue</span>(thd, commit_queue);<br>    <span class="hljs-built_in">mysql_mutex_unlock</span>(&amp;LOCK_commit);<br>    <span class="hljs-comment">/* 主备半同步相关 */</span><br>    <span class="hljs-built_in">process_after_commit_stage_queue</span>(thd, commit_queue);<br>    final_queue = commit_queue;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (leave_mutex_before_commit_stage) <span class="hljs-comment">/* 释放sync stage时获得的锁 */</span><br>      <span class="hljs-built_in">mysql_mutex_unlock</span>(leave_mutex_before_commit_stage);<br>    ...<br>  &#125;<br><br>  <span class="hljs-comment">/* 通知队列中所有等待的线程，设置每个线程的thd-&gt;tx_commit_pending标志，</span><br><span class="hljs-comment">     follower线程被唤醒后会调用finish_commit，如果发现事务没有提交，会</span><br><span class="hljs-comment">     调用ha_commit_low函数，此时就不能保证commit的顺序了，finish_commit</span><br><span class="hljs-comment">     函数中的工作大多与process_commit_stage_queue函数对每个事务的处理</span><br><span class="hljs-comment">     重叠，如果已经进行过就不做了。 */</span><br>  Commit_stage_manager::<span class="hljs-built_in">get_instance</span>().<span class="hljs-built_in">signal_done</span>(final_queue);<br>  (<span class="hljs-type">void</span>)<span class="hljs-built_in">finish_commit</span>(thd);<br><br>  ... <span class="hljs-comment">/* 根据Flush Stage设置的rotate_var进行binlog文件的rotate */</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Stage切换"><a href="#Stage切换" class="headerlink" title="Stage切换"></a>Stage切换</h2><p>在ordered_commit函数中，Stage与Stage之间需要调用change_stage函数来进行切换，内部调用的是Commit_stage_manager::enroll_for函数，Commit_stage_manager维护了不同Stage的队列，每个队列的队首线程会主导该阶段所有队列中成员的提交工作，其他线程会挂起等待被唤醒即可，下面看看enroll_for函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Commit_stage_manager::enroll_for</span><span class="hljs-params">(StageID stage, THD *thd,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">mysql_mutex_t</span> *stage_mutex,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      <span class="hljs-type">mysql_mutex_t</span> *enter_mutex)</span> </span>&#123;<br>  <span class="hljs-built_in">lock_queue</span>(stage);<br>  <span class="hljs-comment">/* 首个入队的是leader，为True，上个Stage的leader进入新Stage也可能变为follower */</span><br>  <span class="hljs-type">bool</span> leader = m_queue[stage].<span class="hljs-built_in">append</span>(thd);<br>  ... <span class="hljs-comment">/* COMMIT_ORDER_FLUSH_STAGE与备库回放相关，先无视 */</span><br>  <span class="hljs-built_in">unlock_queue</span>(stage);<br><br>  ...<br><br>  <span class="hljs-comment">/* 释放上个Stage获得的锁 */</span><br>  <span class="hljs-keyword">if</span> (stage_mutex &amp;&amp; need_unlock_stage_mutex) <span class="hljs-built_in">mysql_mutex_unlock</span>(stage_mutex);<br><br>  <span class="hljs-comment">/* 不是leader的线程需要休眠，等待完成提交后被leader唤醒即可 */</span><br>  <span class="hljs-keyword">if</span> (!leader) &#123;<br>    <span class="hljs-built_in">CONDITIONAL_SYNC_POINT_FOR_TIMESTAMP</span>(<span class="hljs-string">&quot;before_follower_wait&quot;</span>);<br>    <span class="hljs-built_in">mysql_mutex_lock</span>(&amp;m_lock_done);<br>    <span class="hljs-keyword">while</span> (thd-&gt;tx_commit_pending) &#123; <span class="hljs-comment">/* 在ordered_commit函数末尾sigal_done函数中被设置 */</span><br>      <span class="hljs-built_in">mysql_cond_wait</span>(&amp;m_stage_cond_binlog, &amp;m_lock_done);<br>    &#125;<br>    <span class="hljs-built_in">mysql_mutex_unlock</span>(&amp;m_lock_done);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/* leader需要获得下个Stage的锁 */</span><br>  <span class="hljs-keyword">if</span> (leader &amp;&amp; enter_mutex != <span class="hljs-literal">nullptr</span>) &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (need_lock_enter_mutex)<br>      <span class="hljs-built_in">mysql_mutex_lock</span>(enter_mutex);<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-built_in">mysql_mutex_assert_owner</span>(enter_mutex);<br>  &#125;<br><br>  ...<br><br>  <span class="hljs-keyword">return</span> leader;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Flush-Stage"><a href="#Flush-Stage" class="headerlink" title="Flush Stage"></a>Flush Stage</h2><p>看下process_flush_stage_queue函数，其内对Redo Log做了刷盘，给每个事务分配了GTID，进而生成了GTID Event，形成了一个事务Binlog内容的完全体，最终把组内所有成员的Binlog Cache内容都写到Binlog的内存Buffer中，外部调用者稍后就会把Buffer内容flush到操作系统的Page Cache中，详情如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MYSQL_BIN_LOG::process_flush_stage_queue</span><span class="hljs-params">(<span class="hljs-type">my_off_t</span> *total_bytes_var, <span class="hljs-type">bool</span> *rotate_var, THD **out_queue_var)</span> </span>&#123;<br>  ...<br>  <span class="hljs-comment">/* 这个函数里会获取flush stage的线程队列，并且清空它使得可以继续组装新的组，</span><br><span class="hljs-comment">     在函数的最后会调用ha_flush_logs函数最终执行innobase_flush_logs函数，</span><br><span class="hljs-comment">     将Redo Log写操作系统Page Cache，innodb_flush_log_at_trx_commit为1时</span><br><span class="hljs-comment">     才会真正刷盘 */</span><br>  THD *first_seen = <span class="hljs-built_in">fetch_and_process_flush_stage_queue</span>();<br>  <br>  <span class="hljs-comment">/* 为组内事务自动分配gtid */</span><br>  <span class="hljs-built_in">assign_automatic_gtids_to_flush_group</span>(first_seen);<br>  <br>  <span class="hljs-comment">/* 将每个线程的binlog cache内容写到binlog文件内存Buffer中 */</span><br>  <span class="hljs-keyword">for</span> (THD *head = first_seen; head; head = head-&gt;next_to_commit) &#123;<br>    <span class="hljs-comment">/* 将current_thd换成head，作用域内仿佛head自己在执行 */</span><br>    <span class="hljs-function">Thd_backup_and_restore <span class="hljs-title">switch_thd</span><span class="hljs-params">(current_thd, head)</span></span>;<br>    <span class="hljs-comment">/* 最终调用的是m_binlog_file-&gt;m_pipeline_head-&gt;write()，只是写到</span><br><span class="hljs-comment">       binlog的内存Buffer中，外部调用者后续会把Buffer内容flush到Page Cache */</span><br>    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">my_off_t</span>&gt; result = <span class="hljs-built_in">flush_thread_caches</span>(head);<br>    total_bytes += result.second;<br>    <span class="hljs-keyword">if</span> (flush_error == <span class="hljs-number">1</span>) flush_error = result.first;<br>  &#125;<br><br>  *out_queue_var = first_seen;<br>  *total_bytes_var = total_bytes;<br>  <span class="hljs-comment">/* 如果binlog文件大小超过最大限制，需要准备rotate */</span><br>  <span class="hljs-keyword">if</span> (total_bytes &gt; <span class="hljs-number">0</span> &amp;&amp;<br>      (m_binlog_file-&gt;<span class="hljs-built_in">get_real_file_size</span>() &gt;= (<span class="hljs-type">my_off_t</span>)max_size ||<br>       <span class="hljs-built_in">DBUG_EVALUATE_IF</span>(<span class="hljs-string">&quot;simulate_max_binlog_size&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>)))<br>    *rotate_var = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> flush_error;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Sync-Stage"><a href="#Sync-Stage" class="headerlink" title="Sync Stage"></a>Sync Stage</h2><p>看下sync_binlog_file函数，内容很简单，就是sync刷盘，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">bool</span>, <span class="hljs-type">bool</span>&gt; <span class="hljs-title">MYSQL_BIN_LOG::sync_binlog_file</span><span class="hljs-params">(<span class="hljs-type">bool</span> force)</span> </span>&#123;<br>  <span class="hljs-type">bool</span> synced = <span class="hljs-literal">false</span>;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sync_period = <span class="hljs-built_in">get_sync_period</span>();<br>  <span class="hljs-comment">/* 用于决定是否sync，其中get_sync_period函数其实就是sync_binlog参数，</span><br><span class="hljs-comment">     sync_counter是有多少组进入到该stage的计数。例如sync_binlog=1代表</span><br><span class="hljs-comment">     每一组都达到要求得sync，sync_binlog=1000代表每100组sync一次，特例</span><br><span class="hljs-comment">     是sync_binlog=0，会直接跳过sync */</span><br>  <span class="hljs-keyword">if</span> (force || (sync_period &amp;&amp; ++sync_counter &gt;= sync_period)) &#123;<br>    sync_counter = <span class="hljs-number">0</span>; <span class="hljs-comment">//重置sync_counter</span><br>    <span class="hljs-comment">/* 调用m_binlog_file-&gt;sync()将binlog内容从操作系统的Page Cache刷盘 */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">DBUG_EVALUATE_IF</span>(<span class="hljs-string">&quot;simulate_error_during_sync_binlog_file&quot;</span>, <span class="hljs-number">1</span>,<br>                         m_binlog_file-&gt;<span class="hljs-built_in">is_open</span>() &amp;&amp; m_binlog_file-&gt;<span class="hljs-built_in">sync</span>())) &#123;<br>      ...<br>    &#125;<br>    synced = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-literal">false</span>, synced);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Commit-Stage"><a href="#Commit-Stage" class="headerlink" title="Commit Stage"></a>Commit Stage</h2><p>首先看下process_commit_stage_queue函数，里面内容比较简单，就是按顺序把每个事务在InnoDB中提交，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MYSQL_BIN_LOG::process_commit_stage_queue</span><span class="hljs-params">(THD *thd, THD *first)</span> </span>&#123;<br>  <span class="hljs-comment">/* 将queue中所有事务在引擎中提交 */</span><br>  <span class="hljs-keyword">for</span> (THD *head = first; head; head = head-&gt;next_to_commit) &#123;<br>    ...<br>    <span class="hljs-comment">/* 将thd换成head，作用域内仿佛head自己在执行 */</span><br>    <span class="hljs-function">Thd_backup_and_restore <span class="hljs-title">switch_thd</span><span class="hljs-params">(thd, head)</span></span>;<br>    <span class="hljs-comment">/* real_commit在刚进入ordered_commit函数时被设置，就是传入的all参数</span><br><span class="hljs-comment">       区分非单语句事务和单语句事务 */</span><br>    <span class="hljs-type">bool</span> all = head-&gt;<span class="hljs-built_in">get_transaction</span>()-&gt;m_flags.real_commit;<br>    <span class="hljs-comment">/* 非外部XA事务，最终透传参数走到ha_commit_low函数 */</span><br>    ::<span class="hljs-built_in">finish_transaction_in_engines</span>(head, all, <span class="hljs-literal">false</span>);<br>  &#125;<br><br>  <span class="hljs-comment">/* 更新GTID状态，把事务们拥有的gtid转为已执行，详见“浅析MySQL GTID” */</span><br>  gtid_state-&gt;<span class="hljs-built_in">update_commit_group</span>(first);<br><br>  <span class="hljs-keyword">for</span> (THD *head = first; head; head = head-&gt;next_to_commit) &#123;<br>    <span class="hljs-function">Thd_backup_and_restore <span class="hljs-title">switch_thd</span><span class="hljs-params">(thd, head)</span></span>;<br>    <span class="hljs-keyword">auto</span> all = head-&gt;<span class="hljs-built_in">get_transaction</span>()-&gt;m_flags.real_commit;<br>    <span class="hljs-comment">/* 对于binlog和innodb分别调用binlog_set_prepared_in_tc函数(啥都没做)</span><br><span class="hljs-comment">       和innobase_set_prepared_in_tc函数，设置为已准备，应该和外部XA事务相关 */</span><br>    trx_coordinator::<span class="hljs-built_in">set_prepared_in_tc_in_engines</span>(head, all);<br>    <span class="hljs-comment">/* 该事务已提交，减少prepared状态XID计数 */</span><br>    <span class="hljs-keyword">if</span> (head-&gt;<span class="hljs-built_in">get_transaction</span>()-&gt;m_flags.xid_written) <span class="hljs-built_in">dec_prep_xids</span>(head);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="innobase-commit"><a href="#innobase-commit" class="headerlink" title="innobase_commit"></a>innobase_commit</h3><p>在ha_commit_low函数中，会调用所有登记被修改的引擎的commit函数，对于binlog而言就是binlog_commit函数，这个函数啥也没做，对于Innodb而言就是innobase_commit函数，接下来看看这个函数，该函数内会为事务添加Commit标记，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">innobase_commit</span><span class="hljs-params">(handlerton *hton, THD *thd, <span class="hljs-type">bool</span> commit_trx)</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>  <span class="hljs-keyword">if</span> (will_commit) &#123;<br>    <span class="hljs-keyword">if</span> (!read_only) &#123;<br>      ... <span class="hljs-comment">/* 进入commit状态，维护Innodb提交线程并发度 */</span><br><br>      <span class="hljs-comment">/* 获得事务在binlog中的提交位置 */</span><br>      ulonglong pos;<br>      <span class="hljs-built_in">thd_binlog_pos</span>(thd, &amp;trx-&gt;mysql_log_file_name, &amp;pos);<br>      trx-&gt;mysql_log_offset = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(pos);<br><br>      <span class="hljs-comment">/* 为了组提交统一刷盘，设置事务为稍后刷盘，在后续innobase_commit_low中被用到 */</span><br>      trx-&gt;flush_log_later = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    ... <span class="hljs-comment">/* 持久化gtid相关 */</span><br><br>    <span class="hljs-comment">/* 基本透传，调用栈trx_commit_for_mysql-&gt;trx_commit-&gt;trx_commit_low */</span><br>    <span class="hljs-built_in">innobase_commit_low</span>(trx);<br><br>    <span class="hljs-keyword">if</span> (!read_only) &#123;<br>      <span class="hljs-comment">/* 设置稍后刷盘为false，trx_commit_complete_for_mysql函数中进行刷盘 */</span><br>      trx-&gt;flush_log_later = <span class="hljs-literal">false</span>;<br>      ... <span class="hljs-comment">/* 离开commit状态，维护Innodb提交线程并发度 */</span><br>    &#125;<br><br>    <span class="hljs-comment">/* 设置事务不再是在2PC中注册的事务 */</span><br>    <span class="hljs-built_in">trx_deregister_from_2pc</span>(trx);<br><br>    <span class="hljs-comment">/* 将提交阶段新产生的Redo Log写入操作系统Page Cache，DDL操作一定刷盘，</span><br><span class="hljs-comment">       DML操作由于之前设置了HA_IGNORE_DURABILITY会直接返回跳过刷盘，不会</span><br><span class="hljs-comment">       因为刷盘而阻塞。其实这一步对于事务完整性已经影响不大，恢复的时候可以拿</span><br><span class="hljs-comment">       着XID去binlog找是否已提交即可。 */</span><br>    <span class="hljs-keyword">if</span> (!read_only) &#123;<br>      <span class="hljs-built_in">trx_commit_complete_for_mysql</span>(trx);<br>    &#125;<br><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    ... <span class="hljs-comment">/* 不提交事务，只标记单语句结束 */</span><br>  &#125;<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在trx_commit_low函数中主要调用了trx_write_serialisation_history和trx_commit_in_memory两个函数。trx_write_serialisation_history函数中分别处理了事务的Insert类型Undo Log和Update类型Undo Log，包括设置状态为TRX_UNDO_CACHED(首页使用率不足3&#x2F;4)、TRX_UNDO_TO_FREE(Insert类型)、TRX_UNDO_TO_PURGE(Update类型)三者之一，根据设置的状态将Undo Log对应的内存对象插入相应链表。随后的trx_commit_in_memory函数会将这些mtr内的操作提交，接下来看一下trx_commit_in_memory函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">trx_commit_in_memory</span><span class="hljs-params">(<span class="hljs-type">trx_t</span> *trx, <span class="hljs-type">const</span> <span class="hljs-type">mtr_t</span> *mtr, <span class="hljs-type">bool</span> serialised)</span></span><br><span class="hljs-function"></span>&#123;<br>  trx-&gt;must_flush_log_later = <span class="hljs-literal">false</span>;<br>  trx-&gt;ddl_must_flush = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">trx_is_autocommit_non_locking</span>(trx)) &#123;...&#125; <span class="hljs-comment">/* 隐喻着只读 */</span><br>  <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 读写事务 */</span><br>    <span class="hljs-comment">/* 内部将trx-&gt;state设置为TRX_STATE_COMMITTED_IN_MEMORY，</span><br><span class="hljs-comment">       从trx_sys的事务链表将本事务摘除，本事务的提交已被其他事务可见 */</span><br>    <span class="hljs-built_in">trx_release_impl_and_expl_locks</span>(trx, serialised);<br>    ...<br>  &#125;<br><br>  ... <span class="hljs-comment">/* gtid持久化相关 */</span><br><br>  <span class="hljs-keyword">if</span> (mtr != <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-comment">/* 清理本事务的insert类型undo log，在commit后再也用不着，</span><br><span class="hljs-comment">       update类型的得留着MVCC使用 */</span><br>    <span class="hljs-keyword">if</span> (trx-&gt;rsegs.m_redo.insert_undo != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-built_in">trx_undo_insert_cleanup</span>(&amp;trx-&gt;rsegs.m_redo, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (trx-&gt;rsegs.m_noredo.insert_undo != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-built_in">trx_undo_insert_cleanup</span>(&amp;trx-&gt;rsegs.m_noredo, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-type">lsn_t</span> lsn = mtr-&gt;<span class="hljs-built_in">commit_lsn</span>();<br>    <span class="hljs-keyword">if</span> (lsn == <span class="hljs-number">0</span>) &#123;...&#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (trx-&gt;flush_log_later) &#123; <span class="hljs-comment">/* innobase_commit中已设置为true，命中该分支 */</span><br>      trx-&gt;must_flush_log_later = <span class="hljs-literal">true</span>;<br>      <span class="hljs-comment">/* 存下来ddl_operation，等会会在trx_init函数中被设为false */</span><br>      trx-&gt;ddl_must_flush = trx-&gt;ddl_operation;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;...&#125;<br>    trx-&gt;commit_lsn = lsn;<br><br>    <span class="hljs-comment">/* 唤醒被挂起的主线程，类似的purge线程这些后台线程也起来工作 */</span><br>    <span class="hljs-built_in">srv_active_wake_master_thread</span>();<br>  &#125;<br><br>  <span class="hljs-comment">/* 减少分配给事务的Rollback Segment的引用计数 */</span><br>  <span class="hljs-keyword">if</span> (trx-&gt;rsegs.m_redo.rseg != <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-type">trx_rseg_t</span> *rseg = trx-&gt;rsegs.m_redo.rseg;<br>    rseg-&gt;trx_ref_count--;<br>    trx-&gt;rsegs.m_redo.rseg = <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  ...<br>  <span class="hljs-comment">/* 会设置trx一部分字段，例如trx-&gt;id=0，后续trx_commit_complete_for_mysql判断</span><br><span class="hljs-comment">     会据此判断是否刷盘Redo Log */</span><br>  <span class="hljs-built_in">trx_init</span>(trx);<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/MySQL/" class="category-chain-item">MySQL</a>
  
  
    <span>></span>
    
  <a href="/categories/MySQL/Server/" class="category-chain-item">Server</a>
  
  
    <span>></span>
    
  <a href="/categories/MySQL/Server/Transaction-Layer/" class="category-chain-item">Transaction Layer</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/MySQL/" class="print-no-link">#MySQL</a>
      
        <a href="/tags/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/" class="print-no-link">#两阶段提交</a>
      
        <a href="/tags/%E7%BB%84%E6%8F%90%E4%BA%A4/" class="print-no-link">#组提交</a>
      
        <a href="/tags/%E8%AF%BB%E6%BA%90%E7%A0%81/" class="print-no-link">#读源码</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>MySQL内部的两阶段提交</div>
      <div>http://captain32.github.io/2023/10/15/MySQL内部的两阶段提交/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>张熙哲</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年10月15日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/10/15/%E5%88%86%E6%94%AF%E4%B8%80%E8%87%B4%E6%80%A7-CT/" title="分支一致性 CT">
                        <span class="hidden-mobile">分支一致性 CT</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'Captain32/Utterances-comment');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
