

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="张熙哲">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、总览在GTID(Global Transaction Identifier)诞生之前，MySQL主备同步是使用“文件名+位移”来确定binlog的复制位点的，在实际使用中很不便利。因此GTID应运而生，每个被写入binlog的事务都被分配了一个全局唯一的GTID，主库和备库通过计算已执行GTID的集合差集就可以确定复制位点了，大大简化确认位点的流程。 GTID是与主库上提交的每个事务关联的唯一">
<meta property="og:type" content="article">
<meta property="og:title" content="浅析MySQL GTID">
<meta property="og:url" content="http://captain32.github.io/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/index.html">
<meta property="og:site_name" content="Captain">
<meta property="og:description" content="一、总览在GTID(Global Transaction Identifier)诞生之前，MySQL主备同步是使用“文件名+位移”来确定binlog的复制位点的，在实际使用中很不便利。因此GTID应运而生，每个被写入binlog的事务都被分配了一个全局唯一的GTID，主库和备库通过计算已执行GTID的集合差集就可以确定复制位点了，大大简化确认位点的流程。 GTID是与主库上提交的每个事务关联的唯一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://captain32.github.io/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/gtid_set.jpeg">
<meta property="og:image" content="http://captain32.github.io/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/sid_map.jpeg">
<meta property="og:image" content="http://captain32.github.io/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/owned_gtids.jpeg">
<meta property="og:image" content="http://captain32.github.io/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/initialize.jpeg">
<meta property="og:image" content="http://captain32.github.io/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/initialize_stack.png">
<meta property="og:image" content="http://captain32.github.io/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/life_cycle.jpeg">
<meta property="og:image" content="http://captain32.github.io/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/assign_gtid.jpeg">
<meta property="og:image" content="http://captain32.github.io/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/assign_gtid_stack.png">
<meta property="og:image" content="http://captain32.github.io/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/write_binlog_stack.png">
<meta property="og:image" content="http://captain32.github.io/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/persist.jpeg">
<meta property="og:image" content="http://captain32.github.io/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/persist_stack1.png">
<meta property="og:image" content="http://captain32.github.io/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/persist_stack2.png">
<meta property="og:image" content="http://captain32.github.io/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/update.jpeg">
<meta property="og:image" content="http://captain32.github.io/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/update_stack.png">
<meta property="og:image" content="http://captain32.github.io/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/replay.jpeg">
<meta property="og:image" content="http://captain32.github.io/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/replay_stack.png">
<meta property="article:published_time" content="2023-10-15T09:57:45.000Z">
<meta property="article:modified_time" content="2023-10-15T12:07:24.939Z">
<meta property="article:author" content="张熙哲">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="读源码">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://captain32.github.io/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/gtid_set.jpeg">
  
  
  
  <title>浅析MySQL GTID - Captain</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"captain32.github.io","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":["home"]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"0DHAyLeOfwqNRanYXNuL4Mhr-gzGzoHsz","app_key":"lq0Ly742okJc5yeBJcZaiHSF","server_url":"https://0dhayleo.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Captain&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/lake.jpeg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">浅析MySQL GTID</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-10-15 17:57" pubdate>
          2023年10月15日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          29k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          240 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="MySQL"
        id="heading-62a004b95946bb97541afa471dcca73a" role="tab" data-toggle="collapse" href="#collapse-62a004b95946bb97541afa471dcca73a"
        aria-expanded="true"
      >
        MySQL
        <span class="list-group-count">(1)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-62a004b95946bb97541afa471dcca73a"
           role="tabpanel" aria-labelledby="heading-62a004b95946bb97541afa471dcca73a">
        
        
          
          
  <div class="category-post-list">
    
    
  </div>

          
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Server"
        id="heading-9aa1b03934893d7134a660af4204f2a9" role="tab" data-toggle="collapse" href="#collapse-9aa1b03934893d7134a660af4204f2a9"
        aria-expanded="true"
      >
        Server
        <span class="list-group-count">(1)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-9aa1b03934893d7134a660af4204f2a9"
           role="tabpanel" aria-labelledby="heading-9aa1b03934893d7134a660af4204f2a9">
        
        
          
          
  <div class="category-post-list">
    
    
  </div>

          
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Replication Layer"
        id="heading-34f55f77d09ea54d74fdb5040ba26611" role="tab" data-toggle="collapse" href="#collapse-34f55f77d09ea54d74fdb5040ba26611"
        aria-expanded="true"
      >
        Replication Layer
        <span class="list-group-count">(1)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-34f55f77d09ea54d74fdb5040ba26611"
           role="tabpanel" aria-labelledby="heading-34f55f77d09ea54d74fdb5040ba26611">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/" title="浅析MySQL GTID"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">浅析MySQL GTID</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
        
      </div>
    </div>
  
        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">浅析MySQL GTID</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一、总览"><a href="#一、总览" class="headerlink" title="一、总览"></a>一、总览</h1><p>在GTID(Global Transaction Identifier)诞生之前，MySQL主备同步是使用“<strong>文件名+位移</strong>”来确定binlog的复制位点的，在实际使用中很不便利。因此GTID应运而生，每个被写入binlog的事务都被分配了一个全局唯一的GTID，主库和备库通过计算<strong>已执行GTID的集合差集</strong>就可以确定复制位点了，大大简化确认位点的流程。</p>
<p>GTID是与主库上提交的每个事务关联的唯一标识符。需要注意的是，不被写入binlog的事务(例如，事务被过滤、事务是只读的)，则不会被分配 GTID，<strong>GTID和binlog是强相关的</strong>。</p>
<p>由于备库重放事务时binlog中已经有了GTID，所以会使用@@SESSION.gtid_next变量直接指定事务的GTID，就不会像主库一样给事务分配新的GTID。为了保证复制的<strong>幂等性</strong>，一旦在给定服务器上提交了某个事务，则该服务器将忽略具有相同GTID的后续事务。</p>
<p>本文将对GTID相关数据结构、状态维护、初始化流程、生命周期进行探究，其中包含的源码取自MySQL 8.0.34，想要深入了解代码实现的同学可以根据注释阅读。</p>
<h1 id="二、为什么需要这么一个ID"><a href="#二、为什么需要这么一个ID" class="headerlink" title="二、为什么需要这么一个ID"></a><strong>二、为什么需要这么一个ID</strong></h1><p>对于分布式系统保证一致性而言，最简单的情况其实就是主备复制，为了能达成一致性，是需要备库把主库执行的事务都执行一遍，并且是按照主库的顺序，这就是<strong>全局顺序一致</strong>。当然为了备库回放的速度，并不需要严格按照主库的顺序，不具有依赖关系的不同事务是可以并发回放的，这也就是Writeset所做的工作，它大概模拟了一个事务间的<strong>因果顺序</strong>。但是仅仅有顺序是不行的，我们需要在分布式系统中唯一标识一个事务，并且能够知道一个事务是否已经执行，那么最简单的办法就是给每个事务分配一个<strong>全局唯一ID</strong>，并且追踪事务是否已执行来保证<strong>幂等性</strong>，那么其实到这里就可以发现GTID就承担起了这个责任，它是我们保证全局顺序一致的一分子。</p>
<h1 id="三、如何开启GTID"><a href="#三、如何开启GTID" class="headerlink" title="三、如何开启GTID"></a><strong>三、如何开启GTID</strong></h1><h2 id="gtid-mode"><a href="#gtid-mode" class="headerlink" title="gtid_mode"></a><strong>gtid_mode</strong></h2><ul>
<li>Scope : Global</li>
<li>Dynamic : Yes</li>
<li>Type : Enumeration</li>
<li>Default Value : OFF</li>
<li>Valid Values：<ul>
<li>OFF：新的和复制事务都使用anonymous</li>
<li>OFF_PERMISSIVE：新的事务都使用anonymous，而复制事务可以使用GTID或anonymous</li>
<li>ON_PERMISSIVE：新的事务都使用 GTID，而复制事务可以使用GTID或anonymous</li>
<li>ON：新的和复制事务都使用 GTID</li>
</ul>
</li>
</ul>
<p>其中 anonymous transaction 用 binlog file 和 position 来标识事务，需要注意的是 SET gtid_mode 的值必须是临近状态，不能跳着设置，即只能如下渐变修改：</p>
<blockquote>
<p>OFF&lt;-&gt;OFF_PERMISSIVE&lt;-&gt;ON_PERMISSIVE&lt;-&gt;ON</p>
</blockquote>
<p>为啥要求这么奇葩？是因为gtid_mode从OFF到ON的切换需要如下流程：</p>
<ol>
<li>将所有机器的gtid_mode从OFF设置为OFF_PERMISSIVE，这时所有机器作为备库都可以接受GTID事务</li>
<li>将所有机器的gtid_mode从OFF_PERMISSIVE设置为ON_PERMISSIVE，这时所有机器作为主库的新事务都变成了GTID事务，在这个状态下机器之间传输的事务<strong>同时有GTID事务和匿名事务</strong></li>
<li><strong>等待所有匿名事务被复制完毕</strong>，这时互相传输的事务只剩下GTID事务了，就可以将所有机器的gtid_mode从ON_PERMISSIVE设置为ON了</li>
</ol>
<p>可以看到ON_PERMISSIVE这个状态就是为了等待遗留匿名事务的复制完成；同理OFF_PERMISSIVE状态就是gtid_mode从ON到OFF时用于等待遗留GITD事务复制完成的<strong>中间过渡状态</strong>。</p>
<h1 id="四、GTID长啥样"><a href="#四、GTID长啥样" class="headerlink" title="四、GTID长啥样"></a><strong>四、GTID长啥样</strong></h1><h2 id="GTID格式"><a href="#GTID格式" class="headerlink" title="GTID格式"></a><strong>GTID格式</strong></h2><p>GTID由两部分组成，source_id是提交该事务的服务器ID也就是server_uuid，是一个Mysql实例的唯一标识，在mysql第一次启动时，会自动生成并持久化到auto.cnf文件，下次启动从中加载即可；transaction_id是在主库上提交事务时分配的事务ID，一般情况下是从1开始无间隙递增的，最大为2^63-1，下面是GTID的格式和一个示例：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GTID</span> = source_id:transaction_id<br><span class="hljs-attribute">3E11FA47</span>-<span class="hljs-number">71</span>CA-<span class="hljs-number">11</span>E1-<span class="hljs-number">9</span>E33-C80AA9429562:<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure>
<p>源码中结构体的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Gtid</span> &#123;<br>  <span class="hljs-comment">/* GTID的服务器号，int类型，可以使用Sid_map将sidno转为sid再得到UUID */</span><br>  rpl_sidno sidno;<br>  <span class="hljs-comment">/* GTID的事务号，int64类型 */</span><br>  rpl_gno gno;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="GTID-Set"><a href="#GTID-Set" class="headerlink" title="GTID Set"></a><strong>GTID Set</strong></h2><p>GTID Set就如同它的名字一样，存的是一个GTID集合，像gtid_executed和gtid_purged变量其实就是GTID Set。因为GTID大多数情况下是连续分配的，所以可以用区间进行简化存储，如下示例：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">3E11FA47</span>-<span class="hljs-number">71</span>CA-<span class="hljs-number">11</span>E1-<span class="hljs-number">9</span>E33-C80AA9429562:<span class="hljs-number">1</span>-<span class="hljs-number">3</span>:<span class="hljs-number">11</span>:<span class="hljs-number">47</span>-<span class="hljs-number">49</span>, <span class="hljs-number">24</span>DA167-<span class="hljs-number">0</span>C0C-<span class="hljs-number">11</span>E8-<span class="hljs-number">8442</span>-<span class="hljs-number">00059</span>A3C7B00:<span class="hljs-number">1</span>-<span class="hljs-number">19</span><br></code></pre></td></tr></table></figure>
<p>其中同一个服务器UUID后面用冒号分隔不同区间，不同服务器的GTID用逗号分隔。<br>源码中有一个Gtid_set类定义，该类对象其实可以看作一系列链表，每个sidno(机器)对应了一条链表，链表内是有序排列的不相交的前闭后开区间，结构体的示意图与定义如下：<br><img src="/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/gtid_set.jpeg" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Gtid_set</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/* 定义了Gtid_set基本组成单位前闭后开区间[start,end) */</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Interval</span> &#123;<br>   <span class="hljs-keyword">public</span>:<br>    rpl_gno start;<br>    rpl_gno end;<br>    <span class="hljs-comment">/* 属于同一个sidno的区间会串成一串 */</span><br>    Interval *next;<br>  &#125;;<br>  ...<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">/* 使用的Sid_map */</span><br>  Sid_map *sid_map;<br>  <span class="hljs-comment">/* 第N个元素代表sidno为N的区间链表头，Gtid_set内绝大多数</span><br><span class="hljs-comment">     函数、迭代器等都是在m_intervals上操作，包括找空闲GTID、</span><br><span class="hljs-comment">     插入GTID、删除GTID、合并区间等等 */</span><br>  Prealloced_array&lt;Interval *, <span class="hljs-number">8</span>&gt; m_intervals;<br>...<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="UUID怎么变成了整数sidno"><a href="#UUID怎么变成了整数sidno" class="headerlink" title="UUID怎么变成了整数sidno"></a><strong>UUID怎么变成了整数sidno</strong></h2><p>从上面的介绍可以发现，明明GTID的第一部分是一个很长的字符串UUID，但代码里怎么就变成了一个整数sidno？这是为了避免在代码内处理过多字符串，所以每个机器都有个全局变量global_sid_map用来对sidno和UUID双向映射，该变量是Sid_map类对象，该类示意图与源码定义如下：<br><img src="/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/sid_map.jpeg" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sid_map</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/* 检查内部数据结构是否已有sid，已有就直接返回对应的sidno，</span><br><span class="hljs-comment">     没有就生成新的sidno添加到内部数据结构并返回sidno */</span><br>  <span class="hljs-function">rpl_sidno <span class="hljs-title">add_sid</span><span class="hljs-params">(<span class="hljs-type">const</span> rpl_sid &amp;sid)</span></span>;<br>  <span class="hljs-comment">/* 将sid映射到sidno */</span><br>  <span class="hljs-function">rpl_sidno <span class="hljs-title">sid_to_sidno</span><span class="hljs-params">(<span class="hljs-type">const</span> rpl_sid &amp;sid)</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-comment">/* 将sidno映射到sid */</span><br>  <span class="hljs-function"><span class="hljs-type">const</span> rpl_sid &amp;<span class="hljs-title">sidno_to_sid</span><span class="hljs-params">(rpl_sidno sidno, <span class="hljs-type">bool</span> need_lock = <span class="hljs-literal">false</span>)</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-comment">/* 获得当前最大的sidno */</span><br>  <span class="hljs-function">rpl_sidno <span class="hljs-title">get_max_sidno</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  ...<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">/* 内部array、map基本元素类型，包含sidno(int类型)</span><br><span class="hljs-comment">     和sid(binary_log::Uuid类型)两部分 */</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    rpl_sidno sidno;<br>    rpl_sid sid;<br>  &#125;;<br>  <span class="hljs-comment">/* 理应为global_sid_lock */</span><br>  <span class="hljs-keyword">mutable</span> Checkable_rwlock *sid_lock;<br>  <span class="hljs-comment">/* 用于将sidno映射为sid */</span><br>  Prealloced_array&lt;Node *, <span class="hljs-number">8</span>&gt; _sidno_to_sid;<br>  <span class="hljs-comment">/* 用于将sid映射为sidno */</span><br>  malloc_unordered_map&lt;rpl_sid, unique_ptr_my_free&lt;Node&gt;, binary_log::Hash_Uuid&gt;<br>      _sid_to_sidno&#123;key_memory_Sid_map_Node&#125;;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="五、机器的GTID状态"><a href="#五、机器的GTID状态" class="headerlink" title="五、机器的GTID状态"></a><strong>五、机器的GTID状态</strong></h1><h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a><strong>系统变量</strong></h2><p>当我们SHOW VARIABLES LIKE ‘%GTID%’的时候，经常可以看到gtid_executed、gtid_owned和gtid_purged这几个变量，它们其实反映出了当前机器的GTID状态，它们的相关介绍如下。</p>
<h3 id="gtid-executed"><a href="#gtid-executed" class="headerlink" title="gtid_executed"></a>gtid_executed</h3><ul>
<li>Scope : Global</li>
<li>Dynamic : No</li>
<li>Type : String</li>
</ul>
<p>代表了当前机器<strong>已经执行过</strong>的所有事务。</p>
<h3 id="gtid-owned"><a href="#gtid-owned" class="headerlink" title="gtid_owned"></a>gtid_owned</h3><ul>
<li>Scope : Global, Session</li>
<li>Dynamic : No</li>
<li>Type : String</li>
</ul>
<p>Global变量表示目前<strong>正在提交</strong>的并且<strong>被分配了GTID</strong>的事务的GTID，Session变量代表当前事务线程拥有(正在执行)的GTID。</p>
<h3 id="gtid-purged"><a href="#gtid-purged" class="headerlink" title="gtid_purged"></a><strong>gtid_purged</strong></h3><ul>
<li>Scope : Global</li>
<li>Dynamic : Yes</li>
<li>Type : String</li>
</ul>
<p>gtid_purged 变量是 gtid_executed 变量的子集，代表了已经执行但已经不在服务器上任何binlog文件中的GTID，意味着无法传给备库回放。</p>
<h2 id="运行时维护"><a href="#运行时维护" class="headerlink" title="运行时维护"></a><strong>运行时维护</strong></h2><h3 id="Gtid-state"><a href="#Gtid-state" class="headerlink" title="Gtid_state"></a><strong>Gtid_state</strong></h3><p>代码中有一个全局变量gtid_state，它是Gtid_state类指针，可以说gtid_state是GTID相关源码中最重要的变量，在后续很多模块都可以看到gtid_state的影子，其内的executed_gtids、owned_gtids、lost_gtids就对应着上面介绍的三个系统变量，在分配GTID的时候也就是调用该类的方法，相关源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Gtid_state</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/* 初始化gtid_state，主要是将全局变量server_uuid解析成</span><br><span class="hljs-comment">     rpl_sid类型变量，调用sid_map.add_sid函数获得sid_no */</span><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-comment">/* 检查gtid是否在executed_gtids中，即已执行 */</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_executed</span><span class="hljs-params">(<span class="hljs-type">const</span> Gtid &amp;gtid)</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-comment">/* 检查gtid是否在owned_gtids中，即正在被某个线程own，执行中 */</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_owned</span><span class="hljs-params">(<span class="hljs-type">const</span> Gtid &amp;gtid)</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-comment">/* 分配GTID时自动计算得到下个gno */</span><br>  <span class="hljs-function">rpl_gno <span class="hljs-title">get_automatic_gno</span><span class="hljs-params">(rpl_sidno sidno)</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-comment">/* 为thd分配一个新的GTID，会加入到owned_gtids中 */</span><br>  <span class="hljs-function">enum_return_status <span class="hljs-title">generate_automatic_gtid</span><span class="hljs-params">(THD *thd,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             rpl_sidno specified_sidno = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             rpl_gno specified_gno = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             rpl_sidno *locked_sidno = <span class="hljs-literal">nullptr</span>)</span></span>;<br>  <span class="hljs-comment">/* 在owned_gtids中绑定GTID和线程的关系 */</span><br>  <span class="hljs-function">enum_return_status <span class="hljs-title">Gtid_state::acquire_ownership</span><span class="hljs-params">(THD *thd, <span class="hljs-type">const</span> Gtid &amp;gtid)</span></span>;<br>  ...<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">/* 理应为global_sid_lock */</span><br>  <span class="hljs-keyword">mutable</span> Checkable_rwlock *sid_lock;<br>  <span class="hljs-comment">/* 使用的Sid_map */</span><br>  <span class="hljs-keyword">mutable</span> Sid_map *sid_map;<br>  <span class="hljs-comment">/* 每个sidno都有一把锁，操作不同sidno下的GTID时减小锁粒度 */</span><br>  Mutex_cond_array sid_locks;<br>  <span class="hljs-comment">/* 代表了binlog中没有存储，无法根据binlog恢复的事务，是executed_gtids的子集 */</span><br>  Gtid_set lost_gtids;<br>  <span class="hljs-comment">/* 代表了本服务器执行过的所有事务 */</span><br>  Gtid_set executed_gtids;<br>  <span class="hljs-comment">/* 代表了分配给某个线程正在执行尚未提交的事务 */</span><br>  Owned_gtids owned_gtids;<br>  <span class="hljs-comment">/* init函数中设置，存服务器的sidno */</span><br>  rpl_sidno server_sidno;<br>  <span class="hljs-comment">/* 用于优化分配gno性能的变量，存的gno大概率无人使用，这样</span><br><span class="hljs-comment">     get_automatic_gno函数就可以从这个变量开始快速尝试 */</span><br>  rpl_gno next_free_gno;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Owned-gtids"><a href="#Owned-gtids" class="headerlink" title="Owned_gtids"></a><strong>Owned_gtids</strong></h3><p>executed_gtids和lost_gtids都是前面介绍过的Gtid_set类型，但是owned_gtids则是Owned_gtids类型，从owned_gtids的功能也可以意识到它跟另外两个不太一样，它在分配GTID时起到了重要作用，需要维护事务和GTID的持有关系。</p>
<p>于是其内用一个数组为每个sidno存了一个Hash Map，可以将gno映射到拥有该GTID的线程ID，在owned_gtids内存的&lt;GTID, THD.id&gt;基本可以认为是正在提交流程中的事务，当事务完成提交后会清掉这个拥有关系，并在executed_gtids中加入GTID，示意图与类定义如下：<br><img src="/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/owned_gtids.jpeg" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Owned_gtids</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/* 将&lt;gtid.gno,owner&gt;的绑定关系添加到sidno_to_hash[gtid.sidno]中 */</span><br>  <span class="hljs-function">enum_return_status <span class="hljs-title">add_gtid_owner</span><span class="hljs-params">(<span class="hljs-type">const</span> Gtid &amp;gtid, my_thread_id owner)</span></span>;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">/* 基本单元，gno和所属线程 */</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    rpl_gno gno;<br>    my_thread_id owner;<br>  &#125;;<br>  <span class="hljs-comment">/* 理应为global_sid_lock */</span><br>  <span class="hljs-keyword">mutable</span> Checkable_rwlock *sid_lock;<br>  <span class="hljs-comment">/* 每个sidno对应一个unordered_map，每个map管理了gno到Node的映射</span><br><span class="hljs-comment">     能快速根据sidno_to_hash[gtid.sidno][gtid.gno]查到其所属线程 */</span><br>  Prealloced_array&lt;malloc_unordered_multimap&lt;rpl_gno, unique_ptr_my_free&lt;Node&gt;&gt; *, <span class="hljs-number">8</span>&gt; sidno_to_hash;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>分配GTID时，gtid_state的acquire_ownership函数就会调用owned_gtids的add_gtid_owner方法，绑定了GTID和事务线程的关系，并且设置线程自己的owned_gtid、owned_sid字段，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">enum_return_status <span class="hljs-title">Gtid_state::acquire_ownership</span><span class="hljs-params">(THD *thd, <span class="hljs-type">const</span> Gtid &amp;gtid)</span> </span>&#123;<br>  <span class="hljs-comment">/* 向owned_gtids中添加gtid和thd的绑定关系 */</span><br>  <span class="hljs-keyword">if</span> (owned_gtids.<span class="hljs-built_in">add_gtid_owner</span>(gtid, thd-&gt;<span class="hljs-built_in">thread_id</span>()) != RETURN_STATUS_OK)<br>    <span class="hljs-keyword">goto</span> err;<br>  <br>  <span class="hljs-comment">/* 设置thd的owned_gtid、owned_sid(为了便利)和最近使用的GTID */</span><br>  thd-&gt;owned_gtid = gtid;<br>  thd-&gt;owned_sid = sid_map-&gt;<span class="hljs-built_in">sidno_to_sid</span>(gtid.sidno);<br>  thd-&gt;rpl_thd_ctx.<span class="hljs-built_in">last_used_gtid_tracker_ctx</span>().<span class="hljs-built_in">set_last_used_gtid</span>(gtid);<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a><strong>持久化</strong></h2><h3 id="mysql-gtid-executed表"><a href="#mysql-gtid-executed表" class="headerlink" title="mysql.gtid_executed表"></a>mysql.gtid_executed表</h3><p>在系统database mysql中存了一张名为gtid_executed的表，该表存的内容是gtid_executed变量的一个子集(有可能最新的部分还没有同步到表里面)，这张表由系统自动创建，它的CREATE TABLE信息如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> gtid_executed (<br>    source_uuid <span class="hljs-type">CHAR</span>(<span class="hljs-number">36</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    interval_start <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    interval_end <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (source_uuid, interval_start)<br>)<br></code></pre></td></tr></table></figure>
<p>其实每行数据就是机器ID加上对应的事务ID区间，与GTID Set很类似。<br>关于何时写入数据到gtid_executed表，有如下规则：</p>
<ul>
<li>打开GTID并且<strong>关闭binlog</strong>的情况下，每个事务提交的时候都会把分配的GTID更新到表中</li>
<li>打开GTID并且<strong>打开binlog</strong>的情况下，从8.0.17开始，Innodb有自己专门的写入gtid_executed表的线程，即innodb&#x2F;clone_gtid_thread，每个事务提交的时候都会把GTID登记到该线程，该线程会将GTID成组写入表中并进行压缩，后面会详细介绍这个过程</li>
</ul>
<p>在代码中有一个Gtid_table_persistor类，该类包含了一系列操作mysql.gtid_executed表的函数，后面介绍的clone_gtid_thread线程就是调用该类的方法来操作mysql.gtid_executed表，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Gtid_table_persistor</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/* mysql.gtid_executed表有三列：source_uuid、interval_start、interval_end */</span><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> uint number_fields = <span class="hljs-number">3</span>;<br>  <span class="hljs-comment">/* 一系列操作mysql.gtid_executed表的函数，读、写、压缩等等 */</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h2><p>GTID相关的初始化主要包括以下几个方面：</p>
<ul>
<li>相关全局变量的初始化：<ul>
<li>global_sid_lock：GTID相关数据结构使用的读写锁</li>
<li>global_sid_map：sidno&lt;-&gt;sid的双向映射</li>
<li>gtid_table_persistor：该对象包含操作mysql.gtid_executed表的一系列方法</li>
</ul>
</li>
<li>gtid_state的初始化：<ul>
<li>设置当前机器的UUID，将其加入global_sid_map获得当前机器的sidno</li>
<li>内部executed_gtids、lost_gtids、previous_gtids_logged等变量的初始化，计算过程可见下图</li>
</ul>
</li>
<li>上面计算得到的previous_gtids_logged写入当前机器新生成的binlog中，作为Previous_gtids</li>
</ul>
<p><img src="/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/initialize.jpeg" srcset="/img/loading.gif" lazyload><br>下面是初始化相关的函数栈与源码：<br><img src="/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/initialize_stack.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp">global_sid_lock<span class="hljs-comment">/* GTID相关全局变量定义 */</span><br>Checkable_rwlock *global_sid_lock = <span class="hljs-literal">nullptr</span>;<br>Sid_map *global_sid_map = <span class="hljs-literal">nullptr</span>;<br>Gtid_state *gtid_state = <span class="hljs-literal">nullptr</span>;<br>Gtid_table_persistor *gtid_table_persistor = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">gtid_server_init</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">/* 设置GTID Mode */</span><br>  global_gtid_mode.<span class="hljs-built_in">set</span>(<span class="hljs-built_in">static_cast</span>&lt;Gtid_mode::value_type&gt;(Gtid_mode::sysvar_mode));<br>  <span class="hljs-comment">/* GTID相关全局变量初始化 */</span><br>  global_sid_lock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Checkable_rwlock</span>();<br>  global_sid_map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Sid_map</span>(global_sid_lock));<br>  gtid_state = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Gtid_state</span>(global_sid_lock, global_sid_map);<br>  gtid_table_persistor = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Gtid_table_persistor</span>();<br>  ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mysqld_main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  ...<br>  <span class="hljs-comment">/* 1.内部调用gtid_server_init函数初始化GTID相关全局变量，</span><br><span class="hljs-comment">     2.调用generate_server_uuid函数为服务器生成UUID存到</span><br><span class="hljs-comment">       server_uuid变量中</span><br><span class="hljs-comment">     3.调用链ha_post_recover-&gt;post_recover_handlerton</span><br><span class="hljs-comment">       -&gt;ha_post_recover-&gt;innobase_post_recover</span><br><span class="hljs-comment">       -&gt;srv_start_threads_after_ddl_recovery</span><br><span class="hljs-comment">       -&gt;gtid_persistor.start()启动gtid persistor线程，</span><br><span class="hljs-comment">       该线程定期将GTID写入mysql.gtid_executed表 */</span><br>  <span class="hljs-built_in">init_server_components</span>();<br>  ...<br>  global_sid_lock-&gt;<span class="hljs-built_in">wrlock</span>();<br>  <span class="hljs-comment">/* 初始化gtid_state */</span><br>  <span class="hljs-type">int</span> gtid_ret = gtid_state-&gt;<span class="hljs-built_in">init</span>();<br>  global_sid_lock-&gt;<span class="hljs-built_in">unlock</span>();<br><br>  <span class="hljs-comment">/* 从mysql.gtid_executed表加载GTID到gtid_state-&gt;executed_gtids */</span><br>  gtid_state-&gt;<span class="hljs-built_in">read_gtid_executed_from_table</span>();<br><br>  <span class="hljs-comment">/* 开启binlog才进行 */</span><br>  <span class="hljs-keyword">if</span> (opt_bin_log) &#123;<br>    <span class="hljs-comment">/* 指向gtid_state-&gt;executed_gtids */</span><br>    Gtid_set *executed_gtids = ...;<br>    <span class="hljs-comment">/* 指向gtid_state-&gt;lost_gtids */</span><br>    Gtid_set *lost_gtids = ...;<br>    <span class="hljs-comment">/* 指向gtid_state-&gt;gtids_only_in_table */</span><br>    Gtid_set *gtids_only_in_table = ...;<br>    <span class="hljs-comment">/* 指向gtid_state-&gt;previous_gtids_logged */</span><br>    Gtid_set *previous_gtids_logged = ...;<br>    <span class="hljs-comment">/* 临时变量，代表历史中已经被purge的binlog中的GTID */</span><br>    <span class="hljs-function">Gtid_set <span class="hljs-title">purged_gtids_from_binlog</span><span class="hljs-params">(global_sid_map, global_sid_lock)</span></span>;<br>    <span class="hljs-comment">/* 临时变量，代表在binlog文件中存储过的GTID */</span><br>    <span class="hljs-function">Gtid_set <span class="hljs-title">gtids_in_binlog</span><span class="hljs-params">(global_sid_map, global_sid_lock)</span></span>;<br>    <span class="hljs-comment">/* 临时变量，代表binlog文件中有但是mysql.gtid_executed表中没有的GTID */</span><br>    <span class="hljs-function">Gtid_set <span class="hljs-title">gtids_in_binlog_not_in_table</span><span class="hljs-params">(global_sid_map, global_sid_lock)</span></span>;<br><br>    <span class="hljs-comment">/* 调用完成后，gtids_in_binlog存最新非空binlog文件中</span><br><span class="hljs-comment">       Previous_gtids_log_event和所有gtid_event的并集；</span><br><span class="hljs-comment">       purged_gtids_from_binlog存最旧binlog文件中的</span><br><span class="hljs-comment">       Previous_gtids_log_event */</span><br>    mysql_bin_log.<span class="hljs-built_in">init_gtid_sets</span>(<br>        &amp;gtids_in_binlog, &amp;purged_gtids_from_binlog,<br>        opt_source_verify_checksum, <span class="hljs-literal">true</span>,<br>        <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>);<br><br>    global_sid_lock-&gt;<span class="hljs-built_in">wrlock</span>();<br><br>    <span class="hljs-comment">/* gtids_in_binlog_not_in_table = gtids_in_binlog - gtids_in_table</span><br><span class="hljs-comment">       目前executed_gtids只加载了表中的GTID */</span><br>    gtids_in_binlog_not_in_table.<span class="hljs-built_in">add_gtid_set</span>(&amp;gtids_in_binlog);<br>    gtids_in_binlog_not_in_table.<span class="hljs-built_in">remove_gtid_set</span>(executed_gtids);<br>    <span class="hljs-comment">/* 把表中没有的GTID持久化到表中 */</span><br>    gtid_state-&gt;<span class="hljs-built_in">save</span>(&amp;gtids_in_binlog_not_in_table);<br>    <span class="hljs-comment">/* 完成executed_gtids的初始化，取两个的并集 */</span><br>    executed_gtids-&gt;<span class="hljs-built_in">add_gtid_set</span>(&amp;gtids_in_binlog_not_in_table);<br><br>    <span class="hljs-comment">/* gtids_only_in_table = executed_gtids - gtids_in_binlog */</span><br>    gtids_only_in_table-&gt;<span class="hljs-built_in">add_gtid_set</span>(executed_gtids)<br>    gtids_only_in_table-&gt;<span class="hljs-built_in">remove_gtid_set</span>(&amp;gtids_in_binlog);<br>    <span class="hljs-comment">/* lost_gtids = gtids_only_in_table + purged_gtids_from_binlog;</span><br><span class="hljs-comment">       lost_gtids代表了binlog中没有存储，无法根据binlog恢复的事务 */</span><br>    lost_gtids-&gt;<span class="hljs-built_in">add_gtid_set</span>(gtids_only_in_table);<br>    lost_gtids-&gt;<span class="hljs-built_in">add_gtid_set</span>(&amp;purged_gtids_from_binlog);<br><br>    <span class="hljs-comment">/* 为本次启动创建的binlog文件准备Previous_gtids_log_event */</span><br>    previous_gtids_logged-&gt;<span class="hljs-built_in">add_gtid_set</span>(&amp;gtids_in_binlog);<br>    <span class="hljs-function">Previous_gtids_log_event <span class="hljs-title">prev_gtids_ev</span><span class="hljs-params">(&amp;gtids_in_binlog)</span></span>;<br><br>    global_sid_lock-&gt;<span class="hljs-built_in">unlock</span>();<br><br>    <span class="hljs-comment">/* 为Previous_gtids_log_event计算checksum，随后写入binlog */</span><br>    (prev_gtids_ev.common_footer)-&gt;checksum_alg =<br>        <span class="hljs-built_in">static_cast</span>&lt;enum_binlog_checksum_alg&gt;(binlog_checksum_options);<br>    mysql_bin_log.<span class="hljs-built_in">write_event_to_binlog_and_sync</span>(&amp;prev_gtids_ev);<br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="六、GTID的生命周期"><a href="#六、GTID的生命周期" class="headerlink" title="六、GTID的生命周期"></a><strong>六、GTID的生命周期</strong></h1><p><img src="/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/life_cycle.jpeg" srcset="/img/loading.gif" lazyload><br>GTID生命周期主要分为主备两部分，大部分工作是在主库完成，包括分配、构造GTID Event写入binlog、刷写GTID到持久化表、提交完成更新GTID状态；备库上则是根据Relay Log解析GTID，设置到gtid_next中并对事务进行回放。接下来会逐一介绍每个部分。</p>
<h2 id="分配GTID"><a href="#分配GTID" class="headerlink" title="分配GTID"></a><strong>分配GTID</strong></h2><p>分配GTID的时机是事务两阶段提交Commit阶段的Flush Stage，该提交组leader线程会搜索executed_gtids的所有区间间隙，通过检查owned_gtids判断一个GTID当前是否空闲(不被其他事务拥有)，所有检查都完成后便绑定事务和GTID的拥有关系，并且设置next_free_gno方便下次搜索。整个过程都是受global_sid_lock读锁和相应sidno互斥锁保护的，如下图所示：<br><img src="/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/assign_gtid.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>调用栈及源码如下所示，其中process_flush_stage_queue函数内会首先拿到Flush队列的leader线程，然后传给assign_automatic_gtids_to_flush_group函数为组内所有线程的事务分配GTID。<br><img src="/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/assign_gtid_stack.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MYSQL_BIN_LOG::assign_automatic_gtids_to_flush_group</span><span class="hljs-params">(THD *first_seen)</span> </span>&#123;<br>  <span class="hljs-type">bool</span> error = <span class="hljs-literal">false</span>;<br>  <span class="hljs-type">bool</span> is_global_sid_locked = <span class="hljs-literal">false</span>;<br>  rpl_sidno locked_sidno = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">/* 遍历组内所有线程，为其分配GTID */</span><br>  <span class="hljs-keyword">for</span> (THD *head = first_seen; head; head = head-&gt;next_to_commit) &#123;<br>    <span class="hljs-comment">/* gtid_next类型为AUTOMATIC_GTID才需要分配 */</span><br>    <span class="hljs-keyword">if</span> (head-&gt;variables.gtid_next.type == AUTOMATIC_GTID) &#123;<br>      <span class="hljs-comment">/* 为了避免重复加锁释放锁，组内所有线程只加一次 */</span><br>      <span class="hljs-keyword">if</span> (!is_global_sid_locked) &#123;<br>        global_sid_lock-&gt;<span class="hljs-built_in">rdlock</span>();<br>        is_global_sid_locked = <span class="hljs-literal">true</span>;<br>      &#125;<br>      <span class="hljs-comment">/* 为线程事务自动生成gtid</span><br><span class="hljs-comment">         其中head-&gt;get_transaction()-&gt;get_rpl_transaction_ctx()</span><br><span class="hljs-comment">         就是thd-&gt;m_transaction-&gt;m_rpl_transaction_ctx，线程THD类</span><br><span class="hljs-comment">         绑事务的时候会进行初始化，*/</span><br>      <span class="hljs-keyword">if</span> (gtid_state-&gt;<span class="hljs-built_in">generate_automatic_gtid</span>(<br>              head,<br>              head-&gt;<span class="hljs-built_in">get_transaction</span>()-&gt;<span class="hljs-built_in">get_rpl_transaction_ctx</span>()-&gt;<span class="hljs-built_in">get_sidno</span>(), <span class="hljs-comment">/* 理应为0 */</span><br>              head-&gt;<span class="hljs-built_in">get_transaction</span>()-&gt;<span class="hljs-built_in">get_rpl_transaction_ctx</span>()-&gt;<span class="hljs-built_in">get_gno</span>(), <span class="hljs-comment">/* 理应为0 */</span><br>              &amp;locked_sidno) != RETURN_STATUS_OK) &#123;<br>        head-&gt;commit_error = THD::CE_FLUSH_GNO_EXHAUSTED_ERROR;<br>        error = <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>       ... <span class="hljs-comment">/* 仅仅assert检查，不做修改 */</span><br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-comment">/* 必要时释放锁 */</span><br>  <span class="hljs-keyword">if</span> (locked_sidno &gt; <span class="hljs-number">0</span>) gtid_state-&gt;<span class="hljs-built_in">unlock_sidno</span>(locked_sidno);<br>  <span class="hljs-keyword">if</span> (is_global_sid_locked) global_sid_lock-&gt;<span class="hljs-built_in">unlock</span>();<br><br>  <span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>generate_automatic_gtid函数内主要是加锁、解锁的操作，核心是调用get_automatic_gno函数为GTID分配gno，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">enum_return_status <span class="hljs-title">Gtid_state::generate_automatic_gtid</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    THD *thd, rpl_sidno specified_sidno, rpl_gno specified_gno,</span></span><br><span class="hljs-params"><span class="hljs-function">    rpl_sidno *locked_sidno)</span> </span>&#123;<br>  <span class="hljs-comment">/* 在上一级caller中传了locked_sidno，所以这里是false，</span><br><span class="hljs-comment">     后续忽略基于该变量进行的判断 */</span><br>  <span class="hljs-type">bool</span> locked_sidno_was_passed_null = (locked_sidno == <span class="hljs-literal">nullptr</span>);<br><br>  <span class="hljs-comment">/* 上一级caller中调用了global_sid_lock-&gt;rdlock()，</span><br><span class="hljs-comment">     与gtid_state的sid_lock一样，所以可以通过检查 */</span><br>  sid_lock-&gt;<span class="hljs-built_in">assert_some_lock</span>();<br><br>  <span class="hljs-comment">/* GTID_MODE是ON_PERMISSIVE或ON，生成一个新的GTID */</span><br>  <span class="hljs-keyword">if</span> (global_gtid_mode.<span class="hljs-built_in">get</span>() &gt;= Gtid_mode::ON_PERMISSIVE) &#123;<br>    <span class="hljs-comment">/* 传入的specified_sidno和specified_gno理应都为0 */</span><br>    Gtid automatic_gtid = &#123;specified_sidno, specified_gno&#125;;<br>    <span class="hljs-comment">/* 获得服务器的sidno，设置到GTID中 */</span><br>    <span class="hljs-keyword">if</span> (automatic_gtid.sidno == <span class="hljs-number">0</span>) automatic_gtid.sidno = <span class="hljs-built_in">get_server_sidno</span>();<br>    <br>    <span class="hljs-comment">/* 上一级caller是在循环中为组内每一个线程分配GTID，第一次调用</span><br><span class="hljs-comment">       本函数时*locked_sidno=0，会给服务器的sidno加锁，之后就不</span><br><span class="hljs-comment">       需要了，除非有个线程事务换了其他sidno */</span><br>    <span class="hljs-type">bool</span> need_to_lock_sidno = *locked_sidno != automatic_gtid.sidno);<br>    <span class="hljs-keyword">if</span> (need_to_lock_sidno) &#123;<br>      <span class="hljs-comment">/* 切换了sidno，需要将之前sidno的锁释放掉再上新sidno的锁 */</span><br>      <span class="hljs-keyword">if</span> (*locked_sidno != <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">unlock_sidno</span>(*locked_sidno);<br>      <span class="hljs-built_in">lock_sidno</span>(automatic_gtid.sidno);<br>      <span class="hljs-comment">/* locked_sidno存了当前上锁的sidno，上一级caller负责释放 */</span><br>      *locked_sidno = automatic_gtid.sidno;<br>    &#125;<br><br>    <span class="hljs-comment">/* 生成GTID的gno部分 */</span><br>    <span class="hljs-keyword">if</span> (automatic_gtid.gno == <span class="hljs-number">0</span>) &#123;<br>      automatic_gtid.gno = <span class="hljs-built_in">get_automatic_gno</span>(automatic_gtid.sidno);<br>      <span class="hljs-comment">/* 设置next_free_gno，该变量会在get_automatic_gno函数</span><br><span class="hljs-comment">         中被使用，可以使得下一次分配更快，不需要频繁检查owned_gtids */</span><br>      <span class="hljs-keyword">if</span> (automatic_gtid.sidno == <span class="hljs-built_in">get_server_sidno</span>() &amp;&amp; automatic_gtid.gno != <span class="hljs-number">-1</span>)<br>        next_free_gno = automatic_gtid.gno + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">/* 在owned_gtids中绑定GTID和线程的关系，设置线程相关变量 */</span><br>    <span class="hljs-built_in">acquire_ownership</span>(thd, automatic_gtid);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">/* GTID_MODE是OFF或OFF_PERMISSIVE，标记一下即可 */</span><br>    thd-&gt;owned_gtid.sidno = THD::OWNED_SIDNO_ANONYMOUS;<br>    thd-&gt;owned_gtid.gno = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">acquire_anonymous_ownership</span>();<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>get_automatic_gno函数则会从next_free_gno开始，遍历executed_gtids内所有区间的空隙，递增并检查是否被own，没有就代表找到了真正空闲的gno随后可以返回，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">rpl_gno <span class="hljs-title">Gtid_state::get_automatic_gno</span><span class="hljs-params">(rpl_sidno sidno)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-comment">/* ivit是遍历executed_gtids内sidno下所有区间[start,end)的迭代器 */</span><br>    <span class="hljs-function">Gtid_set::Const_interval_iterator <span class="hljs-title">ivit</span><span class="hljs-params">(&amp;executed_gtids, sidno)</span></span>;<br>    <span class="hljs-comment">/* 本服务器生成的GTID，直接从next_free_gno开始检查，加快分配速度 */</span><br>    Gtid next_candidate = &#123;sidno, sidno == <span class="hljs-built_in">get_server_sidno</span>() ? next_free_gno : <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-comment">/* 从头遍历所有区间，从空隙中找第一个没有被提交并且没有被own的gno */</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">const</span> Gtid_set::Interval *iv = ivit.<span class="hljs-built_in">get</span>();<br>        rpl_gno next_interval_start = iv != <span class="hljs-literal">nullptr</span> ? iv-&gt;start : GNO_END;<br>        <span class="hljs-comment">/* 从当前空隙里逐一尝试GTID，没有被占有即可返回 */</span><br>        <span class="hljs-keyword">while</span> (next_candidate.gno &lt; next_interval_start) &#123;<br>            <span class="hljs-keyword">if</span> (owned_gtids.<span class="hljs-built_in">is_owned_by</span>(next_candidate, <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> next_candidate.gno;<br>            next_candidate.gno++;<br>        &#125;<br>        <span class="hljs-comment">/* 已经耗尽gno，报错 */</span><br>        <span class="hljs-keyword">if</span> (iv == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-built_in">my_error</span>(ER_GNO_EXHAUSTED, <span class="hljs-built_in">MYF</span>(<span class="hljs-number">0</span>));<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">/* 设置gno为该区间的结束位置，下一轮尝试的开始 */</span><br>        <span class="hljs-keyword">if</span> (next_candidate.gno &lt; iv-&gt;end) next_candidate.gno = iv-&gt;end;<br>        ivit.<span class="hljs-built_in">next</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="写入binlog"><a href="#写入binlog" class="headerlink" title="写入binlog"></a><strong>写入binlog</strong></h2><p><img src="/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/write_binlog_stack.png" srcset="/img/loading.gif" lazyload><br>在Flush Stage分配完各个事务的GTID后，就会将binlog cache中的内容flush到binlog文件中(Page Cache内)，这个过程中与GTID相关的部分首先会构建一个Gtid_log_event，把该event作为本事务的第一个event写到binlog中，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MYSQL_BIN_LOG::write_transaction</span><span class="hljs-params">(THD *thd, binlog_cache_data *cache_data,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      Binlog_event_writer *writer)</span> </span>&#123;<br>  int64 sequence_number, last_committed;<br>  <span class="hljs-comment">/* sequence_number代表事务的逻辑时间戳，last_committed代表本事务</span><br><span class="hljs-comment">     必须在sequence_number等于last_committed的事务提交之后再提交，</span><br><span class="hljs-comment">     用于维持备库执行事务的顺序 */</span><br>  m_dependency_tracker.<span class="hljs-built_in">get_dependency</span>(thd, sequence_number, last_committed);<br>  <span class="hljs-comment">/* 事务在本机上提交的物理时间戳 */</span><br>  ulonglong immediate_commit_timestamp = <span class="hljs-built_in">my_micro_time</span>();<br>  <span class="hljs-comment">/* 事务在源机器上提交的物理时间戳，这里省略了后面对于 undefined 的处理，</span><br><span class="hljs-comment">     本机就是源机时等于 immediate 时间戳 */</span><br>  ulonglong original_commit_timestamp = thd-&gt;variables.original_commit_timestamp;<br>  <span class="hljs-comment">/* 本机版本 */</span><br>  <span class="hljs-type">uint32_t</span> trx_immediate_server_version = <span class="hljs-built_in">do_server_version_int</span>(::server_version);<br>  <span class="hljs-comment">/* 源机版本，省略后面对于 undefined 的判断 */</span><br>  <span class="hljs-type">uint32_t</span> trx_original_server_version = thd-&gt;variables.original_server_version;<br>  <span class="hljs-comment">/* 构建 Gtid_log_event */</span><br>  <span class="hljs-function">Gtid_log_event <span class="hljs-title">gtid_event</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      thd, cache_data-&gt;is_trx_cache(), last_committed, sequence_number,</span></span><br><span class="hljs-params"><span class="hljs-function">      cache_data-&gt;may_have_sbr_stmts(), original_commit_timestamp,</span></span><br><span class="hljs-params"><span class="hljs-function">      immediate_commit_timestamp, trx_original_server_version,</span></span><br><span class="hljs-params"><span class="hljs-function">      trx_immediate_server_version)</span></span>;<br>  <br>  <span class="hljs-comment">/* 根据 binlog cache 的 size 设置事务长度到构建 Gtid_log_event 中 */</span><br>  gtid_event.<span class="hljs-built_in">set_trx_length_by_cache_size</span>(cache_data-&gt;<span class="hljs-built_in">get_byte_position</span>(),<br>                                          writer-&gt;<span class="hljs-built_in">is_checksum_enabled</span>(),<br>                                          cache_data-&gt;<span class="hljs-built_in">get_event_counter</span>());<br>  <span class="hljs-comment">/* 将构建Gtid_log_event写到binlog文件中 */</span><br>  <span class="hljs-type">bool</span> ret = gtid_event.<span class="hljs-built_in">write</span>(writer);<br>  ... <span class="hljs-comment">/* flush剩余event */</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>binlog文件中GTID Event的body内容如下：</p>
<table>
<thead>
<tr>
<th><strong>Name</strong></th>
<th><strong>Format</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>GTID_FLAGS</td>
<td>1 byte</td>
<td>00000001 &#x3D; Transaction may have changes logged with SBR. In 5.6, 5.7.0-5.7.18, and 8.0.0-8.0.1, this flag is always set. Starting in 5.7.19 and 8.0.2, this flag is cleared if the transaction only contains row events. It is set if any part of the transaction is written in statement format.</td>
</tr>
<tr>
<td>SID</td>
<td>16 byte sequence</td>
<td>UUID representing the SID</td>
</tr>
<tr>
<td>GNO</td>
<td>8 byte integer</td>
<td>Group number, second component of GTID.</td>
</tr>
<tr>
<td>logical clock timestamp typecode</td>
<td>1 byte integer</td>
<td>The type of logical timestamp used in the logical clock fields.</td>
</tr>
<tr>
<td>last_committed</td>
<td>8 byte integer</td>
<td>Store the transaction’s commit parent sequence_number</td>
</tr>
<tr>
<td>sequence_number</td>
<td>8 byte integer</td>
<td>The transaction’s logical timestamp assigned at prepare phase</td>
</tr>
<tr>
<td>immediate_commit_timestamp</td>
<td>7 byte integer</td>
<td>Timestamp of commit on the immediate master</td>
</tr>
<tr>
<td>original_commit_timestamp</td>
<td>7 byte integer</td>
<td>Timestamp of commit on the originating master</td>
</tr>
<tr>
<td>transaction_length</td>
<td>1 to 9 byte integer &#x2F;&#x2F; See net_length_size(ulonglong num)</td>
<td>The packed transaction’s length in bytes, including the Gtid</td>
</tr>
<tr>
<td>immediate_server_version</td>
<td>4 byte integer</td>
<td>Server version of the immediate server</td>
</tr>
<tr>
<td>original_server_version</td>
<td>4 byte integer</td>
<td>Version of the server where the transaction was originally executed</td>
</tr>
</tbody></table>
<h2 id="写入mysql-gtid-executed表"><a href="#写入mysql-gtid-executed表" class="headerlink" title="写入mysql.gtid_executed表"></a><strong>写入mysql.gtid_executed表</strong></h2><p><img src="/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/persist.jpeg" srcset="/img/loading.gif" lazyload><br>前面提到了，从8.0.17开始，InnoDB新增了一个clone_gtid_thread线程，负责将所有事务的GTID刷写到mysql.gtid_executed表中，这个过程在事务提交阶段是异步的，事务线程将GTID写到clone_gtid_thread线程的Buffer中就可以去干别的事了，clone_gtid_thread线程会定期将Buffer中的GTID刷入表中，整个Buffer使用了双缓冲机制。同时clone_gtid_thread线程会承担起mysql.gtid_executed表的压缩工作，定期检查刷GTID Set次数是否达到压缩阈值，到了就会进行一次压缩，因此之前的压缩线程compress_gtid_table从8.0.23开始就默认弃用了。</p>
<p>关于线程的初始化、整个异步刷写流程后面逐一介绍。</p>
<h3 id="持久化线程初始化"><a href="#持久化线程初始化" class="headerlink" title="持久化线程初始化"></a><strong>持久化线程初始化</strong></h3><p>在Innodb中有专门的线程来将GTID写入mysql.gtid_executed表，来缓解提交阶段的工作量。这个线程的启动在之前“初始化”小节内概述了一下，下面看下Clone_persist_gtid::start()函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Clone_persist_gtid::start</span><span class="hljs-params">()</span> </span>&#123;<br>  ...<br>  <span class="hljs-comment">/* 该线程就是Innodb诸多后台线程中的m_gtid_persister，</span><br><span class="hljs-comment">     执行的是clone_gtid_thread函数，该函数就是直接调用</span><br><span class="hljs-comment">     Clone_persist_gtid::periodic_write()函数 */</span><br>  srv_threads.m_gtid_persister =<br>      <span class="hljs-built_in">os_thread_create</span>(clone_gtid_thread_key, <span class="hljs-number">0</span>, clone_gtid_thread, <span class="hljs-keyword">this</span>);<br>  srv_threads.m_gtid_persister.<span class="hljs-built_in">start</span>();<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="添加GTID到持久化线程"><a href="#添加GTID到持久化线程" class="headerlink" title="添加GTID到持久化线程"></a><strong>添加GTID到持久化线程</strong></h3><p><img src="/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/persist_stack1.png" srcset="/img/loading.gif" lazyload><br>如上图所示，这一部分工作是在2PC的提交阶段Commit Stage完成的，并且藏得很深，最终落到了gtid_persistor.add()函数，该函数就是将GTID加入到持久化线程的缓存中，等待后续被持久化到表中，首先看下该函数的调用者trx_release_impl_and_expl_locks函数相关部分的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">trx_release_impl_and_expl_locks</span><span class="hljs-params">(<span class="hljs-type">trx_t</span> *trx, <span class="hljs-type">bool</span> serialised)</span> </span>&#123;<br>  <span class="hljs-comment">/* 从trx的owned_gtid提取GTID信息到gtid_desc中 */</span><br>  Gtid_desc gtid_desc&#123;&#125;;<br>  <span class="hljs-keyword">if</span> (serialised) &#123;<br>    <span class="hljs-keyword">auto</span> &amp;gtid_persistor = clone_sys-&gt;<span class="hljs-built_in">get_gtid_persistor</span>();<br>    gtid_persistor.<span class="hljs-built_in">get_gtid_info</span>(trx, gtid_desc);<br>  &#125;<br>  ...<br>  <span class="hljs-comment">/* 将GTID加到持久化线程的buffer中 */</span><br>  <span class="hljs-keyword">if</span> (serialised) &#123;<br>    <span class="hljs-keyword">if</span> (gtid_desc.m_is_set) &#123;<br>      <span class="hljs-keyword">auto</span> &amp;gtid_persistor = clone_sys-&gt;<span class="hljs-built_in">get_gtid_persistor</span>();<br>      gtid_persistor.<span class="hljs-built_in">add</span>(gtid_desc);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>再来看下gtid_persistor.add()函数的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Clone_persist_gtid::add</span><span class="hljs-params">(<span class="hljs-type">const</span> Gtid_desc &amp;gtid_desc)</span> </span>&#123;<br>  ... <span class="hljs-comment">/* 一些检查 */</span><br><br>  <span class="hljs-comment">/* 缓存内GTID数量过多，并且持久化线程正在工作中，令当前线程等待一下 */</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check_max_gtid_threshold</span>() &amp;&amp; <span class="hljs-built_in">is_thread_active</span>()) &#123;<br>    <span class="hljs-built_in">trx_sys_serialisation_mutex_exit</span>();<br>    <span class="hljs-built_in">wait_flush</span>(<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">trx_sys_serialisation_mutex_enter</span>();<br>  &#125;<br><br>  <span class="hljs-comment">/* 采用双Buffer机制，获得前台Buffer，随后将GTID加入Buffer，</span><br><span class="hljs-comment">     并且递增原子变量m_num_gtid_mem */</span><br>  <span class="hljs-keyword">auto</span> &amp;current_gtids = <span class="hljs-built_in">get_active_list</span>();<br>  current_gtids.<span class="hljs-built_in">push_back</span>(gtid_desc.m_info);<br>  <span class="hljs-type">int</span> current_value = ++m_num_gtid_mem;<br><br>  <span class="hljs-comment">/* 已经到达了缓存数量上限，直接设置m_event事件唤醒持久化线程开刷 */</span><br>  <span class="hljs-keyword">if</span> (current_value == s_gtid_threshold) &#123;<br>    <span class="hljs-built_in">os_event_set</span>(m_event);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="持久化线程周期性刷写"><a href="#持久化线程周期性刷写" class="headerlink" title="持久化线程周期性刷写"></a><strong>持久化线程周期性刷写</strong></h3><p><img src="/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/persist_stack2.png" srcset="/img/loading.gif" lazyload><br>如上图所示，持久化线程执行的是periodic_write函数，其内是一个无限循环，不断调用flush_gtids函数将缓存的GTID刷到mysql.gtid_executed表中，最终落在gtid_table_persistor-&gt;save()函数，其中gtid_table_persistor是mysqld.cc定义的Gtid_table_persistor类型全局变量。</p>
<p>下面逐层看下函数实现，首先看下periodic_write函数，内部循环除了等待一定时间外，就是直接调用flush_gtids函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Clone_persist_gtid::periodic_write</span><span class="hljs-params">()</span> </span>&#123;<br>  ...<br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    ... <span class="hljs-comment">/* 遇到shutdown就break */</span><br>    <span class="hljs-comment">/* 除非需要立即刷，等s_time_threshold毫秒 */</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">flush_immediate</span>()) &#123;<br>      <span class="hljs-built_in">os_event_wait_time</span>(m_event, s_time_threshold);<br>    &#125;<br>    <span class="hljs-built_in">os_event_reset</span>(m_event);<br>    <span class="hljs-comment">/* 刷当前缓存的GTID到表中 */</span><br>    <span class="hljs-built_in">flush_gtids</span>(thd);<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>flush_gtids函数包含了刷写缓存GTID和压缩两个任务，实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Clone_persist_gtid::flush_gtids</span><span class="hljs-params">(THD *thd)</span> </span>&#123;<br>  ...<br>  <span class="hljs-comment">/* Buffer内的GTID数量大于0，进行刷写 */</span><br>  <span class="hljs-keyword">if</span> (m_num_gtid_mem.<span class="hljs-built_in">load</span>() != <span class="hljs-number">0</span>) &#123;<br>    m_flush_in_progress.<span class="hljs-built_in">store</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">/* 双Buffer机制，获得当前前台Buffer并切换，后续就可以刷后台Buffer，</span><br><span class="hljs-comment">       前台Buffer则继续接新增GTID */</span><br>    <span class="hljs-keyword">auto</span> flush_list_number = switch_active_list();<br>    <span class="hljs-comment">/* 进行刷写，后两个参数与recovery相关，暂不关注 */</span><br>    err = <span class="hljs-built_in">write_to_table</span>(flush_list_number, table_gtid_set, sid_map);<br>    m_flush_in_progress.<span class="hljs-built_in">store</span>(<span class="hljs-literal">false</span>);<br>  &#125;<br>  ...<br>  <span class="hljs-comment">/* 检查压缩条件，符合就对表进行压缩，同样落在全局变量</span><br><span class="hljs-comment">     gtid_table_persistor的方法上 */</span><br>  <span class="hljs-type">bool</span> debug_skip = <span class="hljs-built_in">debug_skip_write</span>(<span class="hljs-literal">true</span>);<br>  <span class="hljs-keyword">if</span> (err == <span class="hljs-number">0</span> &amp;&amp; !debug_skip &amp;&amp; (compress_recovery || <span class="hljs-built_in">check_compress</span>())) &#123;<br>    m_compression_counter = <span class="hljs-number">0</span>;<br>    m_compression_gtid_counter = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/* 将非Innodb事务的GTID也持久化到表中 */</span><br>    <span class="hljs-built_in">write_other_gtids</span>();<br>    <span class="hljs-comment">/* 调用压缩 */</span><br>    err = gtid_table_persistor-&gt;<span class="hljs-built_in">compress</span>(thd);<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>write_to_table函数则是从缓存中取出GTID并构成GTID Set，并真正调用gtid_table_persistor-&gt;save()函数进行持久化到表的操作，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Clone_persist_gtid::write_to_table</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> flush_list_number,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       Gtid_set &amp;table_gtid_set,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       Sid_map &amp;sid_map)</span> </span>&#123;<br>  <span class="hljs-function">Gtid_set <span class="hljs-title">write_gtid_set</span><span class="hljs-params">(&amp;sid_map, <span class="hljs-literal">nullptr</span>)</span></span>;<br>  <span class="hljs-comment">/* 获得刚被切为后台Buffer的待刷写Buffer，逐个取出加入到write_gtid_set中 */</span><br>  <span class="hljs-keyword">auto</span> &amp;flush_list = <span class="hljs-built_in">get_list</span>(flush_list_number);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;gtid_info : flush_list) &#123;<br>    <span class="hljs-keyword">auto</span> gtid_str = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *&gt;(&amp;gtid_info[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">auto</span> status = write_gtid_set.<span class="hljs-built_in">add_gtid_text</span>(gtid_str);<br>  &#125;<br>  ...<br>  <span class="hljs-comment">/* 调用gtid_table_persistor-&gt;save()函数真正将GTID持久化到表中 */</span><br>  <span class="hljs-keyword">if</span> (!write_gtid_set.<span class="hljs-built_in">is_empty</span>()) &#123;<br>    ++m_compression_counter;<br>    err = gtid_table_persistor-&gt;<span class="hljs-built_in">save</span>(&amp;write_gtid_set, <span class="hljs-literal">false</span>);<br>  &#125;<br><br>  <span class="hljs-comment">/* 清空后台Buffer，将已刷写Buffer的编号存到对象字段中 */</span><br>  flush_list.<span class="hljs-built_in">clear</span>();<br>  m_flush_number.<span class="hljs-built_in">store</span>(flush_list_number);<br>  <span class="hljs-keyword">return</span> (err);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="提交完成更新GTID状态"><a href="#提交完成更新GTID状态" class="headerlink" title="提交完成更新GTID状态"></a><strong>提交完成更新GTID状态</strong></h2><p><img src="/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/update.jpeg" srcset="/img/loading.gif" lazyload><br>当事务完成提交后，需要在owned_gtids中解除自己和GTID的绑定关系，并且根据提交结果进一步更新gtid_stat，如果提交成功则将GTID加入到executed_gtids中；回滚则更新next_free_gno，方便下次分配时能够分到这些被回滚事务的GTID(更小)。整个流程的调用栈及源码如下：<br><img src="/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/update_stack.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Gtid_state::update_commit_group</span><span class="hljs-params">(THD *first_thd)</span> </span>&#123;<br>  <span class="hljs-comment">/* 给总锁加读锁 */</span><br>  global_sid_lock-&gt;<span class="hljs-built_in">rdlock</span>();<br>  <span class="hljs-comment">/* 组内事务涉及到的所有sidno加锁 */</span><br>  <span class="hljs-built_in">update_gtids_impl_lock_sidnos</span>(first_thd);<br><br>  <span class="hljs-keyword">for</span> (THD *thd = first_thd; thd != <span class="hljs-literal">nullptr</span>; thd = thd-&gt;next_to_commit) &#123;<br>    <span class="hljs-comment">/* 该事务是提交还是rollback */</span><br>    <span class="hljs-type">bool</span> is_commit = (thd-&gt;commit_error != THD::CE_COMMIT_ERROR);<br>    ... <span class="hljs-comment">/* 1.跳过不需要处理GTID的事务 */</span><br>    <span class="hljs-comment">/* 用于处理违反GTID一致性的事务，略过 */</span><br>    <span class="hljs-type">bool</span> more_trx_with_same_gtid_next = <span class="hljs-built_in">update_gtids_impl_begin</span>(thd);<br>    ...<br>    <span class="hljs-comment">/* 释放线程对GTID的拥有权，根据is_commit决定是否将</span><br><span class="hljs-comment">       GTID加入executed_gtids */</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (thd-&gt;owned_gtid.sidno &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">update_gtids_impl_own_gtid</span>(thd, is_commit);<br>    &#125;<br>    ...<br>  &#125;<br><br>  <span class="hljs-comment">/* 释放所有上的锁 */</span><br>  <span class="hljs-built_in">update_gtids_impl_broadcast_and_unlock_sidnos</span>();<br>  global_sid_lock-&gt;<span class="hljs-built_in">unlock</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Gtid_state::update_gtids_impl_own_gtid</span><span class="hljs-params">(THD *thd, <span class="hljs-type">bool</span> is_commit)</span> </span>&#123;<br>  <span class="hljs-comment">/* 解除线程和GTID的绑定关系 */</span><br>  owned_gtids.<span class="hljs-built_in">remove_gtid</span>(thd-&gt;owned_gtid, thd-&gt;<span class="hljs-built_in">thread_id</span>());<br><br>  <span class="hljs-keyword">if</span> (is_commit) &#123;<br>    <span class="hljs-comment">/* 已提交的事务GTID加入到execute_gtids中 */</span><br>    executed_gtids._add_gtid(thd-&gt;owned_gtid);<br>    <span class="hljs-comment">/*  */</span><br>    thd-&gt;rpl_thd_ctx.<span class="hljs-built_in">session_gtids_ctx</span>().<span class="hljs-built_in">notify_after_gtid_executed_update</span>(thd);<br>    <span class="hljs-comment">/* 备库回放线程在开启binlog的情况下，如果被关闭了写binlog的能力，</span><br><span class="hljs-comment">       这些回放的事务就无法记录在binlog中，需要将GTID加入到lost_gtids</span><br><span class="hljs-comment">       和gtids_only_in_table中 */</span><br>    <span class="hljs-keyword">if</span> (thd-&gt;slave_thread &amp;&amp; opt_bin_log &amp;&amp; !opt_log_replica_updates) &#123;<br>      lost_gtids._add_gtid(thd-&gt;owned_gtid);<br>      gtids_only_in_table._add_gtid(thd-&gt;owned_gtid);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">/* 事务回滚，GTID又可用了，根据大小比较回退next_free_gno */</span><br>    <span class="hljs-keyword">if</span> (thd-&gt;owned_gtid.sidno == server_sidno &amp;&amp; next_free_gno &gt; thd-&gt;owned_gtid.gno)<br>      next_free_gno = thd-&gt;owned_gtid.gno;<br>  &#125;<br><br>  <span class="hljs-comment">/* 清理线程内相关字段，gtid_next如果是ASSIGNED_GTID类型就设为undefined */</span><br>  thd-&gt;<span class="hljs-built_in">clear_owned_gtids</span>();<br>  <span class="hljs-keyword">if</span> (thd-&gt;variables.gtid_next.type == ASSIGNED_GTID) &#123;<br>    thd-&gt;variables.gtid_next.<span class="hljs-built_in">set_undefined</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="备库回放"><a href="#备库回放" class="headerlink" title="备库回放"></a><strong>备库回放</strong></h2><p><img src="/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/replay.jpeg" srcset="/img/loading.gif" lazyload><br>当在备库START SLAVE时，备库上会调用start_slave_cmd-&gt;start_slave-&gt;start_slave_threads函数，会为每个源创建两个线程，分别是IO线程和SQL线程，其中IO线程(对应handle_slave_io函数)负责不断从主库获取binlog内容并追加到自己的relay log中，SQL线程(对应handle_slave_sql函数)则不断回放relay log中的event，对于GTID Event，SQL线程会检查GTID并为事务设置gtid_next变量，随后开启事务。其中gtid_next变量的信息如下所示：</p>
<h3 id="gtid-next"><a href="#gtid-next" class="headerlink" title="gtid_next"></a>gtid_next</h3><ul>
<li>Scope : Session</li>
<li>Dynamic : Yes</li>
<li>Type : Enumeration</li>
<li>Default Value : AUTOMATIC</li>
<li>Valid Values :<ul>
<li>AUTOMATIC: 使用自动产生的下一个GTID</li>
<li>ANONYMOUS: 事务没有GTID, 只使用file and position作为标识</li>
<li>UUID:NUMBER: 指定分配</li>
</ul>
</li>
</ul>
<p>gtid_next是主备同步的关键变量，用于保证主备库上同一个事务被分配了相同的GTID。在主库上一般设置为AUTOMATIC也就是自动分配，会为即将写入binlog的事务分配连续自增的GTID；在备库上进行复制事务时，会根据binlog中的GTID event存的GTID，把备库的gtid_next变量设置为一个确切的GTID，之后事务提交完成后，无论事务会不会被写入备库binlog，都会将该GTID加入到gtid_executed变量中，即标记已执行。</p>
<p>在代码中对应的是thd-&gt;variables.gtid_next，该变量标识了GTID分配方式，该字段类型为Gtid_specification，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Gtid_specification</span> &#123;<br>  <span class="hljs-comment">/* GTID所属类型，AUTOMATIC、ANONYMOUS、ASSIGNED_GTID三种 */</span><br>  enum_gtid_type type;<br>  <span class="hljs-comment">/* type为ASSIGNED_GTID会存具体的sidno、gno，否则都为0 */</span><br>  Gtid gtid;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>备库设置gtid_next的调用栈及源码如下：<br><img src="/2023/10/15/%E6%B5%85%E6%9E%90MySQL-GTID/replay_stack.png" srcset="/img/loading.gif" lazyload></p>
<p>备库SQL线程执行GTID Event的时候会调用Gtid_log_event::do_apply_event函数，该函数会设置线程的gtid_next变量，判断事务是否应被取消或跳过，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Gtid_log_event::do_apply_event</span><span class="hljs-params">(Relay_log_info <span class="hljs-type">const</span> *rli)</span> </span>&#123;<br>  <span class="hljs-type">const</span> Gtid_specification *gtid_next = &amp;thd-&gt;variables.gtid_next;<br>  <span class="hljs-comment">/* 在Relay Log某个事务不完整时，会导致thd已经设置了GTID并且在事务中，</span><br><span class="hljs-comment">     这时需要rollback这个不完整的事务 */</span><br>  <span class="hljs-keyword">if</span> (!thd-&gt;<span class="hljs-built_in">owned_gtid_is_empty</span>() ||<br>      (thd-&gt;<span class="hljs-built_in">owned_gtid_is_empty</span>() &amp;&amp; gtid_next-&gt;type == ASSIGNED_GTID)) &#123;<br>    ...<br>    gtid_state-&gt;<span class="hljs-built_in">update_on_rollback</span>(thd);<br>  &#125;<br>  ...<br>  <span class="hljs-comment">/* 将GTID Event内记录的GTID信息spec视情况设置到thd的gtid_next变量中 */</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">set_gtid_next</span>(thd, spec))<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">/* 会判断GTID对应的事务是否需要被取消、跳过，用在之后的</span><br><span class="hljs-comment">     started_processing函数 */</span><br>  enum_gtid_statement_status state = <span class="hljs-built_in">gtid_pre_statement_checks</span>(thd);<br>  <span class="hljs-comment">/* 将GTID Event记录的一系列信息设置到thd相应变量中 */</span><br>  thd-&gt;variables.original_commit_timestamp = original_commit_timestamp;<br>  thd-&gt;<span class="hljs-built_in">set_original_commit_timestamp_for_slave_thread</span>();<br>  thd-&gt;variables.original_server_version = original_server_version;<br>  thd-&gt;variables.immediate_server_version = immediate_server_version;<br>  <span class="hljs-built_in">const_cast</span>&lt;Relay_log_info *&gt;(rli)-&gt;<span class="hljs-built_in">started_processing</span>(<br>      thd-&gt;variables.gtid_next.gtid, original_commit_timestamp,<br>      immediate_commit_timestamp, state == GTID_STATEMENT_SKIP);<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>再细致看一下set_gtid_next函数，该函数会对GTID的executed、owned情况进行检查，设置的gtid_next变量会被gtid_pre_statement_checks函数用于判断是否应该跳过事务，set_gtid_next函数实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">set_gtid_next</span><span class="hljs-params">(THD *thd, <span class="hljs-type">const</span> Gtid_specification &amp;spec)</span> </span>&#123;<br>  ... <span class="hljs-comment">/* 检查thd的owned_gtid需要是空的 */</span><br>  <span class="hljs-comment">/* 根据GTID类型区分，对于备库回放来说只可能是ANONYMOUS或ASSIGNED */</span><br>  <span class="hljs-keyword">switch</span> (spec.type) &#123;<br>    <span class="hljs-keyword">case</span> AUTOMATIC_GTID:<br>      thd-&gt;variables.gtid_next.<span class="hljs-built_in">set_automatic</span>();<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> ANONYMOUS_GTID:<br>      <span class="hljs-comment">/* 开启GTID的模式下不允许 */</span><br>      <span class="hljs-keyword">if</span> (global_gtid_mode.<span class="hljs-built_in">get</span>() == Gtid_mode::ON) &#123;<br>        <span class="hljs-built_in">my_error</span>(ER_CANT_SET_GTID_NEXT_TO_ANONYMOUS_WHEN_GTID_MODE_IS_ON, <span class="hljs-built_in">MYF</span>(<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">goto</span> err;<br>      &#125;<br>      thd-&gt;variables.gtid_next.<span class="hljs-built_in">set_anonymous</span>();<br>      thd-&gt;owned_gtid.sidno = THD::OWNED_SIDNO_ANONYMOUS;<br>      thd-&gt;owned_gtid.gno = <span class="hljs-number">0</span>;<br>      gtid_state-&gt;<span class="hljs-built_in">acquire_anonymous_ownership</span>();<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> ASSIGNED_GTID:<br>      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">/* GTID不应是关闭模式 */</span><br>        <span class="hljs-keyword">if</span> (global_gtid_mode.<span class="hljs-built_in">get</span>() == Gtid_mode::OFF) &#123;<br>          <span class="hljs-built_in">my_error</span>(ER_CANT_SET_GTID_NEXT_TO_GTID_WHEN_GTID_MODE_IS_OFF, <span class="hljs-built_in">MYF</span>(<span class="hljs-number">0</span>));<br>          <span class="hljs-keyword">goto</span> err;<br>        &#125;<br>        <br>        <span class="hljs-comment">/* 获得sidno对应的锁 */</span><br>        gtid_state-&gt;<span class="hljs-built_in">lock_sidno</span>(spec.gtid.sidno);<br>        <span class="hljs-comment">/* GTID已经被执行过了，仅仅设置gtid_next，不设置owned_gtid，</span><br><span class="hljs-comment">           用于之后gtid_pre_statement_checks函数判断是否跳过执行事务 */</span><br>        <span class="hljs-keyword">if</span> (gtid_state-&gt;<span class="hljs-built_in">is_executed</span>(spec.gtid)) &#123;<br>          thd-&gt;variables.gtid_next = spec;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/* 检查该GTID是否已经被某个线程拥有，没有的话赋予拥有权，</span><br><span class="hljs-comment">           否则不断在while循环内等待GTID被释放 */</span><br>        <span class="hljs-keyword">if</span> (!gtid_state-&gt;<span class="hljs-built_in">is_owned</span>(spec.gtid)) &#123;<br>          <span class="hljs-keyword">if</span> (gtid_state-&gt;<span class="hljs-built_in">acquire_ownership</span>(thd, spec.gtid)) <span class="hljs-keyword">goto</span> err;<br>          thd-&gt;variables.gtid_next = spec;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">/* 等待GTID拥有权释放出来 */</span><br>          gtid_state-&gt;<span class="hljs-built_in">wait_for_gtid</span>(thd, spec.gtid);<br>          ...<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> PRE_GENERATE_GTID: &#123;<br>      Gtid_specification new_spec = spec;<br>      gtid_state-&gt;<span class="hljs-built_in">lock_sidno</span>(new_spec.gtid.sidno);<br>      new_spec.gtid.gno = gtid_state-&gt;<span class="hljs-built_in">get_automatic_gno</span>(new_spec.gtid.sidno);<br>      <span class="hljs-keyword">if</span> (new_spec.gtid.gno == <span class="hljs-number">-1</span>) <span class="hljs-keyword">goto</span> err;<br>      <span class="hljs-keyword">if</span> (gtid_state-&gt;<span class="hljs-built_in">acquire_ownership</span>(thd, new_spec.gtid)) <span class="hljs-keyword">goto</span> err;<br>      new_spec.type = ASSIGNED_GTID;<br>      thd-&gt;variables.gtid_next = new_spec;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  ...<br>  <span class="hljs-keyword">if</span> (lock_count == <span class="hljs-number">2</span>) gtid_state-&gt;<span class="hljs-built_in">unlock_sidno</span>(spec.gtid.sidno);<br>  <span class="hljs-keyword">if</span> (lock_count &gt;= <span class="hljs-number">1</span>) global_sid_lock-&gt;<span class="hljs-built_in">unlock</span>();<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/MySQL/" class="category-chain-item">MySQL</a>
  
  
    <span>></span>
    
  <a href="/categories/MySQL/Server/" class="category-chain-item">Server</a>
  
  
    <span>></span>
    
  <a href="/categories/MySQL/Server/Replication-Layer/" class="category-chain-item">Replication Layer</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/MySQL/" class="print-no-link">#MySQL</a>
      
        <a href="/tags/%E8%AF%BB%E6%BA%90%E7%A0%81/" class="print-no-link">#读源码</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>浅析MySQL GTID</div>
      <div>http://captain32.github.io/2023/10/15/浅析MySQL-GTID/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>张熙哲</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年10月15日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/10/15/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-GFS/" title="分布式文件系统 GFS">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">分布式文件系统 GFS</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/10/15/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-Frangipani/" title="分布式文件系统 Frangipani">
                        <span class="hidden-mobile">分布式文件系统 Frangipani</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'Captain32/Utterances-comment');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
